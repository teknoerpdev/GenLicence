{"version":3,"file":"jsstore.worker.commonjs2.min.js","mappings":"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","sources":["webpack://jsstore/webpack/bootstrap","webpack://jsstore/webpack/runtime/define property getters","webpack://jsstore/webpack/runtime/hasOwnProperty shorthand","webpack://jsstore/webpack/runtime/make namespace object","webpack://jsstore/./src/common/utils/promise_resolve.ts","webpack://jsstore/./src/common/enums.ts","webpack://jsstore/./src/common/utils/promise.ts","webpack://jsstore/./src/worker/model/table_meta.ts","webpack://jsstore/./src/worker/meta_helper.ts","webpack://jsstore/./src/worker/model/db_meta.ts","webpack://jsstore/./src/common/utils/for_obj.ts","webpack://jsstore/./src/worker/utils/log_helper.ts","webpack://jsstore/./src/worker/idbutil/index.ts","webpack://jsstore/./src/common/utils/promise_all.ts","webpack://jsstore/./src/worker/utils/promise_reject.ts","webpack://jsstore/./src/worker/utils/get_error.ts","webpack://jsstore/./src/worker/executors/base.ts","webpack://jsstore/./src/worker/utils/get_error_from_exception.ts","webpack://jsstore/./src/worker/utils/get_data_type.ts","webpack://jsstore/./src/worker/utils/is_null.ts","webpack://jsstore/./src/worker/executors/insert/values_checker.ts","webpack://jsstore/./src/worker/executors/update/schema_checker.ts","webpack://jsstore/./src/worker/executors/query_helper.ts","webpack://jsstore/./src/worker/executors/insert/index.ts","webpack://jsstore/./src/worker/constants/index.ts","webpack://jsstore/./src/worker/utils/set_cross_browser_idb.ts","webpack://jsstore/./src/worker/utils/is_array.ts","webpack://jsstore/./src/worker/utils/get_keys.ts","webpack://jsstore/./src/worker/utils/get_length.ts","webpack://jsstore/./src/worker/utils/get_object_first_key.ts","webpack://jsstore/./src/worker/executors/select/then_evaluator.ts","webpack://jsstore/./src/worker/executors/select/where.ts","webpack://jsstore/./src/worker/executors/select/not_where.ts","webpack://jsstore/./src/worker/utils/remove_space.ts","webpack://jsstore/./src/worker/executors/select/order_by.ts","webpack://jsstore/./src/worker/utils/get_regex_from_like.ts","webpack://jsstore/./src/worker/utils/clone.ts","webpack://jsstore/./src/worker/utils/compare.ts","webpack://jsstore/./src/worker/executors/where_checker.ts","webpack://jsstore/./src/worker/executors/base_fetch.ts","webpack://jsstore/./src/worker/executors/select/regex.ts","webpack://jsstore/./src/worker/executors/select/join.ts","webpack://jsstore/./src/worker/memory_store/index.ts","webpack://jsstore/./src/worker/executors/select/index.ts","webpack://jsstore/./src/worker/utils/is_object.ts","webpack://jsstore/./src/worker/executors/select/in.ts","webpack://jsstore/./src/worker/executors/select/base_select.ts","webpack://jsstore/./src/worker/executors/select/group_by.ts","webpack://jsstore/./src/worker/executors/count/not_where.ts","webpack://jsstore/./src/worker/executors/count/where.ts","webpack://jsstore/./src/worker/executors/count/index.ts","webpack://jsstore/./src/worker/executors/count/regex.ts","webpack://jsstore/./src/worker/executors/count/in.ts","webpack://jsstore/./src/worker/utils/resolve.ts","webpack://jsstore/./src/worker/executors/update/update_value.ts","webpack://jsstore/./src/worker/executors/update/index.ts","webpack://jsstore/./src/worker/executors/update/not_where.ts","webpack://jsstore/./src/worker/executors/update/where.ts","webpack://jsstore/./src/worker/executors/update/regex.ts","webpack://jsstore/./src/worker/executors/update/in.ts","webpack://jsstore/./src/worker/intersect/index.ts","webpack://jsstore/./src/worker/executors/drop_db.ts","webpack://jsstore/./src/worker/union/index.ts","webpack://jsstore/./src/worker/executors/remove/where.ts","webpack://jsstore/./src/worker/executors/remove/index.ts","webpack://jsstore/./src/worker/executors/remove/in.ts","webpack://jsstore/./src/worker/executors/remove/not_where.ts","webpack://jsstore/./src/worker/executors/remove/regex.ts","webpack://jsstore/./src/worker/executors/clear/index.ts","webpack://jsstore/./src/worker/executors/transaction/index.ts","webpack://jsstore/./src/worker/utils/db_schema.ts","webpack://jsstore/./src/worker/query_manager.ts","webpack://jsstore/./src/worker/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const promiseResolve = (value?) => {\n    return Promise.resolve(value);\n}","import { IErrorType } from \"./interfaces\";\n\nexport const ERROR_TYPE = {\n    InvalidUpdateColumn: \"invalid_update_column\",\n    UndefinedColumn: \"undefined_column\",\n    UndefinedValue: \"undefined_value\",\n    UndefinedColumnName: \"undefined_column_name\",\n    UndefinedDbName: \"undefined_database_name\",\n    UndefinedColumnValue: \"undefined_column_value\",\n    NotArray: \"not_array\",\n    NoValueSupplied: \"no_value_supplied\",\n    ColumnNotExist: \"column_not_exist\",\n    NoIndexFound: \"no_index_found\",\n    InvalidOp: \"invalid_operator\",\n    NullValue: \"null_value\",\n    WrongDataType: \"wrong_data_type\",\n    TableNotExist: \"table_not_exist\",\n    DbNotExist: \"db_not_exist\",\n    ConnectionAborted: \"connection_aborted\",\n    ConnectionClosed: \"connection_closed\",\n    NotObject: \"not_object\",\n    InvalidConfig: \"invalid_config\",\n    DbBlocked: \"Db_blocked\",\n    IndexedDbNotSupported: \"indexeddb_not_supported\",\n    NullValueInWhere: \"null_value_in_where\",\n    InvalidJoinQuery: 'invalid_join_query',\n    InvalidQuery: 'invalid_query',\n    ImportScriptsFailed: 'import_scripts_failed',\n    MethodNotExist: 'method_not_exist',\n    Unknown: \"unknown\",\n    InvalidMiddleware: \"invalid_middleware\"\n} as IErrorType;\n\nif (process.env.NODE_ENV !== 'production') {\n    Object.assign(ERROR_TYPE, {\n        InvalidOrderQuery: 'invalid_order_query',\n        InvalidGroupQuery: 'invalid_group_query'\n    });\n}\n\nexport enum WORKER_STATUS {\n    Registered = \"registerd\",\n    Failed = \"failed\",\n    NotStarted = \"not_started\"\n}\n\nexport enum DATA_TYPE {\n    String = \"string\",\n    Object = \"object\",\n    Array = \"array\",\n    Number = \"number\",\n    Boolean = \"boolean\",\n    Null = \"null\",\n    DateTime = \"date_time\"\n}\n\nexport enum API {\n    InitDb = \"init_db\",\n    Get = \"get\",\n    Set = \"set\",\n    Select = \"select\",\n    Insert = \"insert\",\n    Update = \"update\",\n    Remove = \"remove\",\n    OpenDb = \"open_db\",\n    Clear = \"clear\",\n    DropDb = \"drop_db\",\n    Count = \"count\",\n    ChangeLogStatus = \"change_log_status\",\n    Terminate = \"terminate\",\n    Transaction = \"transaction\",\n    CloseDb = \"close_db\",\n    Union = \"union\",\n    Intersect = \"intersect\",\n    ImportScripts = \"import_scripts\",\n    Middleware = \"middleware\"\n}\n\nexport enum EVENT {\n    RequestQueueEmpty = \"requestQueueEmpty\",\n    RequestQueueFilled = \"requestQueueFilled\",\n    Upgrade = \"upgrade\",\n    Create = \"create\",\n    Open = \"open\"\n}\n\nexport enum QUERY_OPTION {\n    Where = \"where\",\n    Like = 'like',\n    Regex = 'regex',\n    In = 'in',\n    Equal = \"=\",\n    Between = '-',\n    GreaterThan = '>',\n    LessThan = '<',\n    GreaterThanEqualTo = \">=\",\n    LessThanEqualTo = \"<=\",\n    NotEqualTo = \"!=\",\n    Aggregate = \"aggregate\",\n    Max = \"max\",\n    Min = \"min\",\n    Avg = \"avg\",\n    Count = \"count\",\n    Sum = \"sum\",\n    List = \"list\",\n    Or = \"or\",\n    Skip = \"skip\",\n    Limit = \"limit\",\n    And = \"and\",\n    IgnoreCase = \"ignoreCase\",\n    Then = \"then\"\n}\n\nexport enum IDB_MODE {\n    ReadOnly = \"readonly\",\n    ReadWrite = \"readwrite\"\n}\n\nexport enum OCCURENCE {\n    First = 'f',\n    Last = 'l',\n    Any = 'a'\n}\n\nexport enum CONNECTION_STATUS {\n    Connected = \"connected\",\n    Closed = \"closed\",\n    NotStarted = \"not_started\",\n    UnableToStart = \"unable_to_start\",\n    ClosedByJsStore = \"closed_by_jsstore\"\n}","export const promise = <T>(cb: (res, rej?) => any) => {\n    return new Promise<T>(cb);\n}","import { ITable, IAlterQuery, IColumn, TColumns } from \"@/common\";\n\nexport class TableMeta {\n    name: string;\n    columns: IColumn[] = [];\n    primaryKey: string;\n    autoIncColumnValue = {};\n    alter?: IAlterQuery;\n\n    constructor(table: ITable) {\n        this.columns = this.setColumn(table.columns);\n        this.name = table.name;\n        this.alter = table.alter || {};\n    }\n\n    setColumn(tableColumns: TColumns) {\n        const columns = [];\n        for (const columnName in tableColumns) {\n            const column: IColumn = tableColumns[columnName] as any;\n            column.name = columnName;\n            if (column.autoIncrement) {\n                this.autoIncColumnValue[columnName] = 0;\n            }\n            if (column.primaryKey) {\n                this.primaryKey = columnName;\n            }\n            column.enableSearch = column.enableSearch == null ? true : column.enableSearch;\n            const existingColumnIndex = this.columns.indexOf(q => q.name === columnName);\n            if (existingColumnIndex < 0) {\n                columns.push(column);\n            }\n            else {\n                const existingColumn = this.columns[existingColumnIndex];\n                Object.assign(existingColumn, column);\n            }\n        }\n        return columns;\n    }\n\n\n}","import { IDBUtil } from \"@/worker/idbutil\";\nimport { promise } from \"@/common\";\n\nexport class MetaHelper {\n    static tableName = \"JsStore_Meta\";\n    static autoIncrementKey(tableName: string, columnName: string) {\n        return `JsStore_${tableName}_${columnName}_Value`;\n    }\n    static dbSchema = `JsStore_DbSchema`;\n\n    static set(key, value, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.put({\n                key, value\n            });\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static get(key, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.get(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result && result.value);\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static remove(key, util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        const store = util.objectStore(MetaHelper.tableName);\n\n        return promise((res, rej) => {\n            const req = store.delete(\n                util.keyRange(key)\n            );\n            req.onsuccess = res;\n            req.onerror = rej;\n        });\n    }\n}","import { IDataBase } from \"@/common\";\nimport { TableMeta } from \"./table_meta\";\nimport { MetaHelper } from \"@worker/meta_helper\";\n\nexport class DbMeta {\n    name: string;\n    version: number;\n    tables: TableMeta[];\n\n    constructor(db: IDataBase) {\n        this.name = db.name;\n        this.version = db.version || 1;\n        db.tables.push({\n            name: MetaHelper.tableName,\n            columns: {\n                key: {\n                    primaryKey: true\n                },\n                value: {\n                    enableSearch: false\n                }\n            },\n        })\n        this.tables = db.tables.map(table => {\n            return new TableMeta(table);\n        });\n    }\n}","export const forObj = (obj: object, cb: (key, value) => void) => {\n    for (const key in obj) {\n        cb(key, obj[key]);\n    }\n}","import { ERROR_TYPE, IError } from \"@/common\";\n\nexport class LogHelper implements IError {\n    type: string;\n    message: string;\n    private info_: any;\n\n    status: boolean;\n\n    log(msg) {\n        if (this.status) {\n            console.log(msg);\n        }\n    }\n\n    constructor(type: string, info?) {\n        this.type = type;\n        this.info_ = info;\n        this.message = this.getMsg_();\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n\n    logError() {\n        console.error(this.get());\n    }\n\n\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_() {\n        let errMsg: string;\n        const info = this.info_;\n        const errorHandler = {\n            [ERROR_TYPE.NotArray]() {\n                errMsg = \"Supplied value is not an array\";\n            },\n            [ERROR_TYPE.UndefinedColumn]() {\n                errMsg = \"Column is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedValue]() {\n                errMsg = \"Value is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedColumnName]() {\n                errMsg = \"Column name is undefined '\" + info['TableName'] + \"'\";\n            },\n            [ERROR_TYPE.UndefinedDbName]() {\n                errMsg = \"Database name is not supplied\";\n            },\n            [ERROR_TYPE.UndefinedColumnValue]() {\n                errMsg = \"Column value is undefined\";\n            },\n            [ERROR_TYPE.NoValueSupplied]() {\n                errMsg = \"No value is supplied\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Op Value '\" + info['Op'] + \"'\";\n            },\n            [ERROR_TYPE.ColumnNotExist]() {\n                const column = info['column'];\n                errMsg = info['isOrder'] ?\n                    (\n                        process.env.NODE_ENV !== 'production' && info.isJoin ?\n                            `Column '${column}' in order query is invalid. Please use '<table>.<column>' format for specifying a column in join query.` :\n                            `Column '${column}' in order query does not exist`\n                    ) :\n                    `Column '${column}' does not exist`;\n            },\n            [ERROR_TYPE.NoIndexFound]() {\n                errMsg = \"No index found for column '\" + info['column'] + \"'. Query can not be executed without index.\";\n            },\n            [ERROR_TYPE.NullValue]() {\n                errMsg = \"Null value is not allowed for column '\" + info['ColumnName'] + \"'\";\n            },\n            [ERROR_TYPE.WrongDataType]() {\n                errMsg = \"Supplied value for column '\" + info['column'] +\n                    \"' have wrong data type\";\n            },\n            [ERROR_TYPE.TableNotExist]() {\n                errMsg = \"Table '\" + info['tableName'] + \"' does not exist\";\n            },\n            [ERROR_TYPE.DbNotExist]() {\n                errMsg = `Database with name ${info['dbName']} does not exist`;\n            },\n            [ERROR_TYPE.NotObject]() {\n                errMsg = \"supplied value is not object\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Config '\" + info['Config'] + \" '\";\n            },\n            [ERROR_TYPE.DbBlocked]() {\n                errMsg = `database is blocked, cant be deleted right now`;\n            },\n            [ERROR_TYPE.NullValueInWhere]() {\n                errMsg = `Null/undefined is not allowed in where. Column '${info['column']}' has null`;\n            },\n            [ERROR_TYPE.MethodNotExist]() {\n                errMsg = `method '${info}' does not exist.`;\n            },\n            [ERROR_TYPE.IndexedDbNotSupported]() {\n                errMsg = \"Browser does not support indexeddb\";\n            },\n            getInfo() {\n                errMsg = info;\n            },\n            [ERROR_TYPE.InvalidJoinQuery]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.ImportScriptsFailed]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.InvalidMiddleware]() {\n                errMsg = `No function ${info} is found.`;\n            },\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            Object.assign(errorHandler, {\n                [ERROR_TYPE.InvalidOrderQuery]() {\n                    errorHandler.getInfo();\n                },\n                [ERROR_TYPE.InvalidGroupQuery]() {\n                    errorHandler.getInfo();\n                },\n            })\n        }\n        const errorType = this.type;\n        const method = errorHandler[errorType];\n        if (method) {\n            method();\n        }\n        else {\n            if (!errorType) {\n                this.type = ERROR_TYPE.Unknown\n            }\n            errMsg = this.message;\n        }\n        return errMsg;\n    }\n}","import { DbMeta, TableMeta } from \"@worker/model\";\nimport { IDB_MODE, QUERY_OPTION, promise, forObj, IColumn, IDataBase, InitDbResult } from \"@/common\";\nimport { LogHelper, userDbSchema } from \"@worker/utils\";\nimport { MetaHelper } from \"../meta_helper\";\n\n\nexport class IDBUtil {\n\n    db: DbMeta;\n\n    con: IDBDatabase;\n    tx: IDBTransaction;\n\n    logger = new LogHelper(null);\n\n    emptyTx() {\n        if (!this.tx) return;\n        this.tx.oncomplete = null;\n        this.tx.onabort = null;\n        this.tx.onerror = null;\n        this.tx = null;\n    }\n\n    createTransactionIfNotExist(tables: string[], mode?: IDB_MODE) {\n        if (!this.tx) {\n            this.createTransaction(tables, mode);\n        }\n    }\n\n    createTransaction(tables: string[], mode = IDB_MODE.ReadWrite) {\n        this.tx = this.con.transaction(tables, mode);\n        return promise((res, rej) => {\n            this.tx.oncomplete = res;\n            this.tx.onabort = res;\n            this.tx.onerror = rej;\n        });\n    }\n\n    keyRange(value, op?) {\n        let keyRange: IDBKeyRange;\n        switch (op) {\n            case QUERY_OPTION.Between: keyRange = IDBKeyRange.bound(value.low, value.high, false, false); break;\n            case QUERY_OPTION.GreaterThan: keyRange = IDBKeyRange.lowerBound(value, true); break;\n            case QUERY_OPTION.GreaterThanEqualTo: keyRange = IDBKeyRange.lowerBound(value); break;\n            case QUERY_OPTION.LessThan: keyRange = IDBKeyRange.upperBound(value, true); break;\n            case QUERY_OPTION.LessThanEqualTo: keyRange = IDBKeyRange.upperBound(value); break;\n            default: keyRange = IDBKeyRange.only(value); break;\n        }\n        return keyRange;\n    }\n\n    objectStore(name: string) {\n        return this.tx.objectStore(name);\n    }\n\n    abortTransaction() {\n        if (this.tx) {\n            this.tx.abort();\n        }\n    }\n\n    close() {\n        if (this.con) {\n            this.con.close();\n        }\n        // wait for 100 ms before success\n        return promise(res => {\n            this.con = null;\n            setTimeout(res, 100);\n        });\n    }\n\n    initDb(db: DbMeta) {\n        let isDbCreated = false;\n        const dbVersion = db.version;\n        let oldVersion;\n        const initLogic = (res, rej) => {\n            const dbOpenRequest = indexedDB.open(db.name, dbVersion);\n            dbOpenRequest.onsuccess = () => {\n                this.con = dbOpenRequest.result;\n                this.con.onversionchange = (e: any) => {\n                    // if (e.newVersion === null) { // An attempt is made to delete the db\n                    e.target.close(); // Manually close our connection to the db\n                    // }\n                }\n\n                res({\n                    isCreated: isDbCreated,\n                    oldVersion: oldVersion,\n                    newVersion: dbVersion\n                } as InitDbResult);\n            }\n\n            dbOpenRequest.onerror = (e) => {\n                console.error(\"error\", e);\n                rej(e);\n            };\n\n            dbOpenRequest.onupgradeneeded = (e: IDBVersionChangeEvent) => {\n                oldVersion = e.oldVersion;\n                const target: {\n                    result: IDBDatabase,\n                    transaction: IDBTransaction\n                } = (e as any).target\n                const upgradeConnection = target.result;\n                isDbCreated = true;\n                const transaction = target.transaction;\n                const storeNames = upgradeConnection.objectStoreNames;\n                const createObjectStore = (table: TableMeta) => {\n                    const option: IDBObjectStoreParameters = table.primaryKey ? {\n                        keyPath: table.primaryKey\n                    } : {\n                            autoIncrement: true\n                        }\n\n                    const store = upgradeConnection.createObjectStore(table.name, option);\n                    table.columns.forEach(column => {\n                        addColumn(store, column)\n                    });\n                }\n                const addColumn = (store: IDBObjectStore, column: IColumn) => {\n                    const columnName = column.name;\n                    if (column.enableSearch && !store.indexNames.contains(columnName)) {\n                        const options = column.primaryKey ? { unique: true } : { unique: column.unique };\n                        options['multiEntry'] = column.multiEntry;\n                        const keyPath = column.keyPath == null ? columnName : column.keyPath;\n                        store.createIndex(columnName, keyPath, options);\n                    }\n                }\n                const deleteColumn = (store: IDBObjectStore, table: TableMeta, columnName: string) => {\n                    const index = table.columns.findIndex(q => q.name === columnName);\n                    if (index >= 0) {\n                        table.columns.splice(index, 1);\n                        store.deleteIndex(columnName);\n                    }\n                }\n                db.tables.forEach(table => {\n                    if (!storeNames.contains(table.name)) {\n                        return createObjectStore(table);\n                    }\n                    const store = transaction.objectStore(table.name);\n                    for (let i = oldVersion + 1; i <= dbVersion; i++) {\n                        const alterQuery = table.alter[i];\n                        if (alterQuery) {\n                            if (alterQuery.add) {\n                                const newColumns = table.setColumn(alterQuery.add);\n                                newColumns.forEach(column => {\n                                    addColumn(store, column);\n                                    table.columns.push(column);\n                                })\n                            }\n                            forObj(\n                                alterQuery.drop || {}, ((columnName) => {\n                                    deleteColumn(store, table, columnName);\n                                })\n                            )\n                            forObj(\n                                alterQuery.modify || {}, ((columnName, column: IColumn) => {\n                                    const shouldDelete = column.multiEntry || column.keyPath || column.unique;\n                                    let targetColumn = table.columns.find(q => q.name === columnName);\n                                    const newColumn = Object.assign(targetColumn, column);\n                                    newColumn.name = columnName;\n                                    if (shouldDelete) {\n                                        deleteColumn(store, table, columnName);\n                                        addColumn(store, newColumn);\n                                        table.columns.push(newColumn);\n                                    }\n                                })\n                            )\n                        }\n                    }\n                });\n\n                for (let i = 0, length = storeNames.length; i < length; i++) {\n                    const storeName = storeNames.item(i);\n                    const tableIndex = db.tables.findIndex(qry => qry.name === storeName);\n                    if (tableIndex < 0) {\n                        upgradeConnection.deleteObjectStore(storeName);\n                    }\n                }\n\n            }\n        }\n        return promise<InitDbResult>(initLogic)\n    }\n}","export const promiseAll = <T>(promises: any) => {\n    return Promise.all<T>(promises);\n};","export const promiseReject = (value) => {\n    return Promise.reject(value);\n}","import { LogHelper } from \"./log_helper\";\n\nexport const getError = (e) => {\n    const customError = e instanceof LogHelper;\n    if (customError) {\n        e.logError();\n        return (e as LogHelper).get();\n    }\n    else {\n        let error;\n        if (e.name) {\n            error = new LogHelper(e.name);\n            error.message = e.message;\n        }\n        else {\n            error = new LogHelper((e as any).target.error.name);\n            error.message = (e as any).target.error.message;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            error.logError();\n        }\n        return error.get();\n    }\n}","import { IDBUtil } from \"@worker/idbutil\";\nimport { IInsertQuery, ISelectQuery, IUpdateQuery } from \"@/common\";\nimport { promiseReject, getErrorFromException } from \"@worker/utils\";\n\nexport class Base {\n\n    get db() {\n        return this.util.db;\n    }\n\n    util: IDBUtil;\n    query: IInsertQuery | ISelectQuery | IUpdateQuery;\n\n    rowAffected = 0;\n    isTxQuery = false;\n    objectStore: IDBObjectStore;\n    tableName: string;\n\n    protected results: any[] = [];\n\n    table(name?: string) {\n        const tableName = name || this.tableName;\n        return this.db.tables.find(q => q.name === tableName)\n    }\n\n    primaryKey(tableName?: string) {\n        const query = this.query as ISelectQuery;\n        if (!query.from && query.store && query.meta) {\n            const primaryKey = query.meta.primaryKey;\n            if (process.env.NODE_ENV !== 'production') {\n                if (primaryKey == null) {\n                    delete query.store;\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}`);\n                }\n            }\n            return primaryKey;\n        }\n        const table = this.table(tableName);\n        if (process.env.NODE_ENV !== 'production') {\n            if (table == null && query.store) {\n                delete query.store;\n                const metaValue = query.meta;\n                if (!metaValue || !metaValue.primaryKey) {\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}. Please supply primary key in meta field.`);\n                }\n            }\n        }\n        return table.primaryKey;\n    }\n\n\n    protected getColumnInfo(columnName: string, tableName?: string) {\n        return this.table(tableName).columns.find(column => column.name === columnName);\n    }\n\n\n\n    onException(ex: DOMException, type?) {\n        console.error(ex);\n        this.util.abortTransaction();\n        return promiseReject(\n            getErrorFromException(ex, type)\n        );\n    }\n}","import { ERROR_TYPE } from \"@/common\"\nimport { getError } from \"./get_error\";\n\nexport const getErrorFromException = (ex, type = ERROR_TYPE.InvalidQuery) => {\n    ex.name = type;\n    return getError(ex);\n}","import { DATA_TYPE } from \"@/common\";\n\nexport const getDataType = (value) => {\n    if (value == null) {\n        return DATA_TYPE.Null;\n    }\n    const type = typeof value;\n    switch (type) {\n        case 'object':\n            if (Array.isArray(value)) {\n                return DATA_TYPE.Array;\n            }\n            if (value instanceof Date) {\n                return DATA_TYPE.DateTime;\n            }\n    }\n    return type;\n}","export const isNull = (value) => {\n    if (value == null) {\n        return true;\n    } else {\n        switch (typeof value) {\n            // case 'string': return value.length === 0;\n            case 'number': return isNaN(value);\n        }\n    }\n    return false;\n};","import { TableMeta } from \"@/worker/model/table_meta\";\nimport { IColumn, TStringAny, ERROR_TYPE, DATA_TYPE, IInsertQuery } from \"@/common\";\nimport { getDataType, LogHelper, isNull } from \"@/worker/utils\";\n\n\nexport class ValuesChecker {\n    table: TableMeta;\n    autoIncrementValue;\n    query: IInsertQuery;\n\n    constructor(table: TableMeta, autoIncValues) {\n        this.table = table;\n        this.autoIncrementValue = autoIncValues;\n    }\n\n    checkAndModifyValues(query: IInsertQuery) {\n        let err: LogHelper;\n        this.query = query;\n        const values = query.values;\n        const ignoreIndexes = [];\n        values.every((item, index) => {\n            err = this.checkAndModifyValue(item);\n            if (query.ignore && err) {\n                ignoreIndexes.push(index);\n                err = null;\n            }\n            return err ? false : true;\n        });\n        ignoreIndexes.forEach(index => {\n            values.splice(index, 1);\n        });\n        return { err, values };\n    }\n\n    private checkAndModifyValue(value) {\n        let error: LogHelper;\n        this.table.columns.every(column => {\n            error = this.checkAndModifyColumnValue_(column, value);\n            return error ? false : true;\n        })\n        return error;\n    }\n\n    private checkNotNullAndDataType_(column: IColumn, value: TStringAny) {\n        // check not null schema\n        if (column.notNull && isNull(value[column.name])) {\n            return this.getError(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n        // check datatype\n        else if (column.dataType && !isNull(value[column.name]) &&\n            getDataType(value[column.name]) !== column.dataType) {\n            return this.getError(ERROR_TYPE.WrongDataType, { column: column.name });\n        }\n    }\n\n    private checkAndModifyColumnValue_(column: IColumn, value: TStringAny) {\n        const columnValue = value[column.name];\n        // check auto increment scheme\n        if (column.autoIncrement) {\n            // if value is null, then create the autoincrement value\n            if (isNull(columnValue)) {\n                value[column.name] = ++this.autoIncrementValue[column.name];\n            }\n            else {\n                if (getDataType(columnValue) === DATA_TYPE.Number) {\n                    // if column value is greater than autoincrement value saved, then make the\n                    // column value as autoIncrement value\n                    if (columnValue > this.autoIncrementValue[column.name]) {\n                        this.autoIncrementValue[column.name] = columnValue;\n                    }\n                }\n            }\n        }\n        // check Default Schema\n        else if (column.default !== undefined && isNull(columnValue)) {\n            value[column.name] = column.default;\n        }\n        const query = this.query;\n        if (query.validation) {\n            return this.checkNotNullAndDataType_(column, value);\n        }\n    }\n\n    private getError(error: string, details: object) {\n        return new LogHelper(error, details);\n    }\n}","import { IColumn, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { LogHelper, isNull, getDataType } from \"@worker/utils\";\nimport { TableMeta } from \"@worker/model\";\n\nexport class SchemaChecker {\n    table: TableMeta;\n    constructor(table: TableMeta) {\n        this.table = table;\n    }\n\n    check(setValue: object, tblName: string) {\n        let log: LogHelper;\n        if (typeof setValue === DATA_TYPE.Object) {\n            if (this.table) {\n                // loop through table column and find data is valid\n                this.table.columns.every((column) => {\n                    if (column.name in setValue) {\n                        log = this.checkByColumn_(column, setValue[column.name]);\n                    }\n                    return log ? false : true;\n                });\n            }\n            else {\n                log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: tblName });\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.NotObject);\n        }\n        return log;\n    }\n\n\n\n    private checkByColumn_(column: IColumn, value) {\n        // check not null schema\n        if (column.notNull === true && isNull(value)) {\n            return new LogHelper(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n\n        // check datatype\n        const type = getDataType(value);\n        const checkFurther = value != null;\n        if (column.dataType && checkFurther) {\n            if (type !== column.dataType && type !== 'object') {\n                return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n            }\n        }\n\n        // check allowed operators\n        if (checkFurther && type === 'object') {\n            const allowedOp = ['+', '-', '*', '/', '{push}'];\n            for (const prop in value) {\n                if (allowedOp.indexOf(prop) < 0 && column.dataType && type !== column.dataType) {\n                    return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n                }\n            }\n        }\n    }\n}","import { IInsertQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, QUERY_OPTION, IUpdateQuery, API } from \"@/common\";\nimport { LogHelper, getDataType } from \"@/worker/utils\";\nimport { DbMeta } from \"../model\";\nimport { ValuesChecker } from \"@worker/executors/insert\";\nimport { SchemaChecker } from \"./update/schema_checker\";\n\nexport class QueryHelper {\n    db: DbMeta;\n\n    constructor(dbSchema: DbMeta) {\n        this.db = dbSchema;\n    }\n\n    validate(api: API, query: IInsertQuery | ISelectQuery | IUpdateQuery) {\n        switch (api) {\n            case API.Select:\n            case API.Remove:\n            case API.Count:\n                return this.checkSelect(query as ISelectQuery);\n            case API.Insert:\n                return this.checkInsertQuery(query as IInsertQuery);\n            case API.Update:\n                return this.checkUpdate(query as IUpdateQuery);\n        }\n    }\n\n    private getTable_(tableName: string) {\n        return this.db.tables.find(q => q.name === tableName);\n    }\n\n    isInsertQryValid(query: IInsertQuery) {\n        const table = this.getTable_(query.into);\n        let log: LogHelper;\n        if (table) {\n            switch (getDataType(query.values)) {\n                case DATA_TYPE.Array:\n                    break;\n                case DATA_TYPE.Null:\n                    log = new LogHelper(ERROR_TYPE.NoValueSupplied);\n                    break;\n                default:\n                    log = new LogHelper(ERROR_TYPE.NotArray);\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.into });\n        }\n        return {\n            table, log\n        };\n    }\n\n    private checkUpdate(query: IUpdateQuery) {\n        let err = new SchemaChecker(this.getTable_(query.in)).\n            check(query.set, query.in);\n        if (err) return err;\n        if (query.where != null) {\n            err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query as any);\n        }\n    }\n\n    private checkSelect(query: ISelectQuery) {\n        if (!query.store) {\n            const table = this.getTable_(query.from);\n            if (!table) {\n                return new LogHelper(ERROR_TYPE.TableNotExist,\n                    { tableName: query.from }\n                );\n            }\n        }\n\n        if (query.where) {\n            const err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query);\n        }\n    }\n\n    private checkForNullInWhere_(query): LogHelper {\n        for (const columnName in query.where) {\n            if (query.where[columnName] == null) {\n                return new LogHelper(ERROR_TYPE.NullValueInWhere, { column: columnName });\n            }\n        }\n    }\n\n    private addGreatAndLessToNotOp_(query: ISelectQuery) {\n        const whereQuery = query.where;\n        const containsNot = (qry: object, keys: string[]) => {\n            return keys.findIndex(key => qry[key][QUERY_OPTION.NotEqualTo] != null) >= 0;\n        };\n        const addToSingleQry = (qry, keys: string[]) => {\n            let value;\n            keys.forEach((prop) => {\n                value = qry[prop];\n                if (value[QUERY_OPTION.NotEqualTo] != null) {\n                    qry[prop][QUERY_OPTION.GreaterThan] = value[QUERY_OPTION.NotEqualTo];\n                    if (qry[QUERY_OPTION.Or] === undefined) {\n                        qry[QUERY_OPTION.Or] = {};\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    else if (qry[QUERY_OPTION.Or][prop] === undefined) {\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    qry[QUERY_OPTION.Or][prop][QUERY_OPTION.LessThan] = value[QUERY_OPTION.NotEqualTo];\n                    delete qry[prop][QUERY_OPTION.NotEqualTo];\n                }\n            });\n            return qry;\n        };\n        switch (getDataType(whereQuery)) {\n            case DATA_TYPE.Object:\n                const queryKeys = Object.keys(whereQuery);\n                if (containsNot(whereQuery, queryKeys)) {\n                    if (queryKeys.length === 1) {\n                        query.where = addToSingleQry(whereQuery, queryKeys);\n                    }\n                    else {\n                        const whereTmpQry = [];\n                        queryKeys.forEach((prop) => {\n                            whereTmpQry.push(addToSingleQry({ [prop]: whereQuery[prop] }, [prop]));\n                        });\n                        query.where = whereTmpQry;\n                    }\n                }\n                break;\n            default:\n                const whereTmp = [];\n                (whereQuery as object[]).forEach(qry => {\n                    const qryKeys = Object.keys(qry);\n                    if (containsNot(qry, qryKeys)) {\n                        qry = addToSingleQry(qry, qryKeys);\n                    }\n                    whereTmp.push(qry);\n                });\n                query.where = whereTmp;\n        }\n    }\n\n    private checkInsertQuery(query: IInsertQuery) {\n        const validResult = this.isInsertQryValid(query);\n        let table = validResult.table;\n        const error = validResult.log;\n        if (error) return error;\n        if (query.skipDataCheck) return;\n        const valueCheckerInstance = new ValuesChecker(table, table.autoIncColumnValue);\n        const { values, err } = valueCheckerInstance.checkAndModifyValues(query);\n        query.values = values;\n        return err;\n    }\n}","export * from \"./values_checker\";\nimport { IInsertQuery, promise, promiseAll, API, IDB_MODE } from \"@/common\";\nimport { Base } from \"@worker/executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { DbMeta } from \"@/worker/model\";\nimport { promiseReject } from \"@/worker/utils\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Insert extends Base {\n\n    query: IInsertQuery;\n\n    private valuesAffected_ = [];\n\n    constructor(query: IInsertQuery, util: IDBUtil) {\n        super();\n        if (query.validation == null) {\n            query.validation = true;\n        }\n        this.query = query;\n        this.util = util;\n        this.tableName = query.into;\n    }\n\n    execute(beforeInsert: () => Promise<any>) {\n        const db = this.db;\n        const err = new QueryHelper(db).validate(API.Insert, this.query);\n        if (err) return promiseReject(err);\n\n        return beforeInsert().then(_ => {\n            return this.insertData_(db).then(_ => {\n                return this.query.return ? this.valuesAffected_ : this.rowAffected\n            })\n        }).catch(err => {\n            this.util.abortTransaction();\n            return promiseReject(err);\n        })\n    }\n\n    private insertData_(db: DbMeta) {\n\n        let onInsertData;\n        let addMethod;\n\n        const query = this.query;\n        if (query.return) {\n            onInsertData = (value) => {\n                this.valuesAffected_.push(value);\n            };\n\n        }\n        else {\n            onInsertData = (value) => {\n                ++this.rowAffected;\n            };\n        }\n        addMethod = (() => {\n            const idbMethod = query.upsert ? \"put\" : \"add\";\n            if (query.ignore && !this.isTxQuery) {\n                return (value) => {\n                    const tx = this.util.con.transaction(query.into, IDB_MODE.ReadWrite);\n                    const objectStore = tx.objectStore(query.into);\n                    return objectStore[idbMethod](value);\n                };\n            }\n            if (!this.isTxQuery) {\n                this.util.createTransaction(\n                    [query.into, MetaHelper.tableName],\n                )\n            }\n            this.objectStore = this.util.objectStore(this.tableName);\n            return (value) => {\n                return this.objectStore[idbMethod](value);\n            };\n        })();\n\n        return promiseAll(\n            query.values.map((value) => {\n                return promise((res, rej) => {\n                    const addResult = addMethod(value);\n                    addResult.onerror = (err) => {\n                        if (query.ignore) {\n                            res();\n                        } else {\n                            rej(err);\n                        }\n                    }\n                    addResult.onsuccess = function () {\n                        onInsertData(value);\n                        res();\n                    };\n                });\n            })\n        ).then(() => {\n            MetaHelper.set(MetaHelper.dbSchema, db, this.util);\n        });\n    }\n}","import { setCrossBrowserIndexedDb } from \"@worker/utils\";\n\nexport const IS_WORKER = typeof (self as any).alert === 'undefined' && typeof ServiceWorkerGlobalScope === 'undefined';\nexport const IS_IDB_SUPPORTED = setCrossBrowserIndexedDb();","export const setCrossBrowserIndexedDb = () => {\n    try {\n        if (!indexedDB) {\n            indexedDB = (self as any).mozIndexedDB ||\n                (self as any).webkitIndexedDB || (self as any).msIndexedDB;\n        }\n        if (indexedDB) {\n            IDBTransaction = IDBTransaction ||\n                (self as any).webkitIDBTransaction || (self as any).msIDBTransaction;\n            (self as any).IDBKeyRange = (self as any).IDBKeyRange ||\n                (self as any).webkitIDBKeyRange || (self as any).msIDBKeyRange;\n        }\n        else {\n            return false;\n        }\n    } catch (ex) {\n        return false;\n    }\n    return true;\n};","export const isArray = (value) => {\n    return Array.isArray(value);\n};","export const getKeys = (value) => {\n    return Object.keys(value);\n};","import { getKeys } from \"./get_keys\"\n\nexport const getLength = (value): Number => {\n    return getKeys(value).length;\n}","export const getObjectFirstKey = (value) => {\n    for (const key in value) {\n        return key;\n    }\n};","import { ICaseOption, QUERY_OPTION } from \"@/common\";\n\nexport class ThenEvaluator {\n    private columnName_: string;\n    private value;\n    private caseQuery_: { [columnName: string]: [ICaseOption] };\n    private caseColumnQuery_: ICaseOption[];\n    private length_: number;\n\n    setCaseAndValue(caseQuery: any, value) {\n        this.caseQuery_ = caseQuery;\n        this.setValue(value);\n    }\n\n    setCaseAndColumn(caseQuery: { [columnName: string]: [ICaseOption] }, columnName: string) {\n        this.caseQuery_ = caseQuery;\n        this.setColumn(columnName);\n        return this;\n    }\n\n    setColumn(columnName: string) {\n        this.columnName_ = columnName;\n        this.caseColumnQuery_ = this.caseQuery_[this.columnName_];\n        this.length_ = this.caseColumnQuery_.length;\n        return this;\n    }\n\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n\n    evaluate() {\n        for (let i = 0; i < this.length_; i++) {\n            if (this.checkCase_(this.caseColumnQuery_[i]) === true) {\n                return this.caseColumnQuery_[i].then;\n            }\n        }\n        const lastThen = this.caseColumnQuery_[this.length_ - 1].then;\n        return lastThen == null ? this.value[this.columnName_] : lastThen;\n    }\n\n    private checkCase_(cond: ICaseOption) {\n        let queryOption;\n        for (queryOption in cond) {\n            switch (queryOption) {\n                case QUERY_OPTION.GreaterThan:\n                    if (this.value[this.columnName_] > cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Equal:\n                    if (this.value[this.columnName_] === cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThan:\n                    if (this.value[this.columnName_] < cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.GreaterThanEqualTo:\n                    if (this.value[this.columnName_] >= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThanEqualTo:\n                    if (this.value[this.columnName_] <= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.NotEqualTo:\n                    if (this.value[this.columnName_] !== cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Between:\n                    if (this.value[this.columnName_] > cond[queryOption].low && this.value[this.columnName_] < cond[queryOption].high) {\n                        return true;\n                    } break;\n            }\n            return false;\n        }\n    }\n}","import { Select } from \"./\";\nimport { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\n\nexport const getCursorOnSuccess = function (this: Select, simpleFn, limitFn, skipFn, skipAndLimitFn) {\n    if (this.limitAtEnd === false && this.skipAtEnd === false) {\n        if (this.skipRecord) {\n            return this.limitRecord ? skipAndLimitFn : skipFn\n        }\n        if (this.limitRecord) {\n            return limitFn;\n        }\n    }\n    return simpleFn;\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op, dir) {\n\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(\n        this.util.keyRange(value, op),\n        dir\n    );\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    })\n\n}\n\nconst executeSkipAndLimitForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nconst executeSkipForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeLimitForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n\n}\n\nexport const executeSimpleForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}","import { Select } from \"./index\";\nimport { LogHelper, promiseReject } from \"@/worker/utils\";\nimport { ERROR_TYPE, IOrderQuery, promise, promiseResolve } from \"@/common\";\nimport { getCursorOnSuccess } from \"./where\";\n\nexport const executeWhereUndefinedLogic = function (this: Select) {\n    let cursorRequest: IDBRequest;\n    const query = this.query;\n    const store = query.store;\n    if (store) {\n        this.results = store as any[];\n        this.setLimitAndSkipEvaluationAtEnd_();\n        return promiseResolve();\n    }\n    const orderQuery = query.order;\n    const objectStore = this.objectStore;\n    if (orderQuery && (orderQuery as IOrderQuery).idbSorting !== false && (orderQuery as IOrderQuery).by) {\n        if (objectStore.indexNames.contains((orderQuery as IOrderQuery).by as string)) {\n            const orderType: IDBCursorDirection = (orderQuery as IOrderQuery).type &&\n                (orderQuery as IOrderQuery).type.toLowerCase() === 'desc' ? 'prev' : 'next';\n            this.sorted = true;\n            cursorRequest = objectStore.index((orderQuery as IOrderQuery).by as string).\n                openCursor(null, orderType);\n        }\n        else {\n            return promiseReject(\n                new LogHelper(\n                    ERROR_TYPE.ColumnNotExist,\n                    { column: (orderQuery as IOrderQuery).by, isOrder: true }\n                )\n            );\n        }\n    }\n    else {\n        cursorRequest = objectStore.openCursor();\n    }\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimple,\n        executeLimit,\n        executeSkip,\n        executeSkipAndLimit\n    );\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    });\n}\n\nconst executeSkipAndLimit = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor: IDBCursorWithValue;\n    return (e) => {\n        cursor = (e as any).target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSkip = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSimple = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            this.pushResult(cursor.value);\n            (cursor as any).continue();\n        }\n        else {\n            onFinished();\n        }\n    };\n}\n\nconst executeLimit = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            this.pushResult(cursor.value);\n            cursor.continue();\n        } else {\n            onFinished();\n        }\n    };\n}\n","export const removeSpace = (value: string) => {\n    return value.replace(/\\s/g, '');\n};","import { Select } from \"./\";\nimport { removeSpace, getDataType, LogHelper } from \"@/worker/utils\";\nimport { ERROR_TYPE, DATA_TYPE, ICaseOption, IColumn, IOrderQuery } from \"@/common\";\n\nexport const processGroupDistinctAggr = function (this: Select) {\n    const query = this.query;\n    if (query.distinct) {\n        const groupBy = [];\n        const result = this.results[0];\n        for (const key in result) {\n            groupBy.push(key);\n        }\n        const primaryKey = this.primaryKey();\n        const index = groupBy.indexOf(primaryKey);\n        groupBy.splice(index, 1);\n        query.groupBy = groupBy.length > 0 ? groupBy : null;\n    }\n    if (query.groupBy) {\n        if (query.aggregate) {\n            this.executeAggregateGroupBy();\n        }\n        else {\n            this.processGroupBy();\n        }\n    }\n    else if (query.aggregate) {\n        this.processAggregateQry();\n    }\n};\n\nconst getOrderColumnInfo = function (this: Select, orderColumn: string) {\n    let column: IColumn;\n    if (!this.query.store) {\n        if (this.query.join == null) {\n            column = this.getColumnInfo(orderColumn);\n        }\n        else {\n            const splittedByDot = removeSpace(orderColumn).split(\".\");\n            const joinOrderColumn = splittedByDot[1];\n            if (process.env.NODE_ENV !== 'production' && joinOrderColumn == null) {\n                new LogHelper(ERROR_TYPE.ColumnNotExist,\n                    { column: orderColumn, isOrder: true, isJoin: true }\n                ).throw()\n            }\n            column = this.getColumnInfo(joinOrderColumn, splittedByDot[0]);\n        }\n    }\n    if (column == null) {\n        const valueFromFirstColumn = this.results[0][orderColumn];\n        if (valueFromFirstColumn) {\n            return {\n                dataType: getDataType(valueFromFirstColumn),\n                name: orderColumn\n            } as IColumn;\n        }\n        throw new LogHelper(ERROR_TYPE.ColumnNotExist,\n            { column: orderColumn, isOrder: true }\n        )\n\n    }\n    return column;\n}\n\nconst compareStringInDesc_ = (a: string, b: string) => {\n    return b.localeCompare(a);\n}\n\nconst compareStringinAsc_ = (a: string, b: string) => {\n    return a.localeCompare(b);\n}\n\nconst compareDefaultInDesc_ = (a: string, b) => {\n    return new String(b).localeCompare(a);\n}\n\nconst compareDefaultinAsc_ = (a, b: string) => {\n    return new String(a).localeCompare(b);\n}\n\nconst compareNumberInDesc_ = (a: number, b: number) => {\n    return b - a;\n}\n\nconst compareNumberinAsc_ = (a: number, b: number) => {\n    return a - b;\n}\n\nconst compareDateInDesc_ = (a: Date, b: Date) => {\n    return b.getTime() - a.getTime();\n}\n\nconst compareDateInAsc_ = (a: Date, b: Date) => {\n    return a.getTime() - b.getTime();\n}\n\nconst getValueComparer_ = (column: IColumn, order: IOrderQuery): (a, b) => number => {\n    switch (column.dataType) {\n        case DATA_TYPE.String:\n            return order.type === 'asc' ? compareStringinAsc_ : compareStringInDesc_;\n        case DATA_TYPE.Number:\n            return order.type === 'asc' ? compareNumberinAsc_ : compareNumberInDesc_;\n        case DATA_TYPE.DateTime:\n            return order.type === 'asc' ? compareDateInAsc_ : compareDateInDesc_;\n        default:\n            return order.type === 'asc' ? compareDefaultinAsc_ : compareDefaultInDesc_;\n    }\n\n}\n\nconst orderBy_ = function (this: Select, order: IOrderQuery) {\n    order.type = getOrderType_(order.type);\n    let orderColumn = order.by;\n    const thenEvaluator = this.thenEvaluator;\n    if (orderColumn != null && typeof orderColumn === DATA_TYPE.Object) {\n        const caseQuery = orderColumn as { [columnName: string]: [ICaseOption] };\n        const getValInAscDesc = (stringComparer, numberComparer) => {\n            return (value1, value2) => {\n                for (const columnName in caseQuery) {\n                    thenEvaluator.setCaseAndValue(caseQuery, value1);\n                    const column1 = thenEvaluator.setColumn(columnName).evaluate();\n                    thenEvaluator.setCaseAndValue(caseQuery, value2);\n                    const column2 = thenEvaluator.setColumn(columnName).evaluate();\n                    switch (typeof value1[column1]) {\n                        case DATA_TYPE.String:\n                            return stringComparer(value1[column1], value2[column2]);\n                        default:\n                            return numberComparer(value1[column1], value2[column2]);\n                    }\n                }\n            }\n        };\n        let sortMethod = order.type === 'asc' ?\n            getValInAscDesc(compareStringinAsc_, compareNumberinAsc_) :\n            getValInAscDesc(compareStringInDesc_, compareNumberInDesc_);\n\n        this.results.sort(sortMethod);\n    }\n    else {\n        const columnInfo = getOrderColumnInfo.call(this, orderColumn as string);\n        if (columnInfo != null) {\n            const orderMethod = getValueComparer_(columnInfo, order);\n            orderColumn = columnInfo.name;\n            if (order.case == null) {\n                this.results.sort((a, b) => {\n                    return orderMethod(a[orderColumn as string], b[orderColumn as string]);\n                });\n            }\n            else {\n                thenEvaluator.setCaseAndColumn({ [orderColumn as string]: order.case }, orderColumn as string);\n                this.results.sort((a, b) => {\n                    return orderMethod(\n                        thenEvaluator.setValue(a).evaluate(),\n                        thenEvaluator.setValue(b).evaluate()\n                    );\n                });\n            }\n        }\n    }\n\n}\n\nconst getOrderType_ = (type: string) => {\n    return type == null ? 'asc' : type.toLowerCase();\n}\n\nexport const processOrderBy = function (this: Select) {\n    const order = this.query.order;\n    if (order && this.results.length > 0 && !this.sorted) {\n        const orderQueryType = getDataType(order);\n        if (orderQueryType === DATA_TYPE.Object) {\n            orderBy_.call(this, order);\n        }\n        else if (orderQueryType === DATA_TYPE.Array) {\n            orderBy_.call(this, order[0]);\n            for (let i = 1, length = (order as any).length; i < length; i++) {\n                const prevOrderQueryBy = order[i - 1].by;\n                const currentOrderQuery: IOrderQuery = order[i];\n                let currentorderQueryBy = currentOrderQuery.by;\n                const orderColumnDetail = getOrderColumnInfo.call(this, currentorderQueryBy as string);\n                if (orderColumnDetail != null) {\n                    currentorderQueryBy = orderColumnDetail.name;\n                    currentOrderQuery.type = getOrderType_(currentOrderQuery.type);\n                    const orderMethod = getValueComparer_(orderColumnDetail, currentOrderQuery);\n                    this.results.sort((a, b) => {\n                        if (a[prevOrderQueryBy] === b[prevOrderQueryBy]) {\n                            return orderMethod(\n                                a[currentorderQueryBy as string],\n                                b[currentorderQueryBy as string]\n                            );\n                        }\n                        return 0;\n                    });\n                }\n            }\n        }\n    }\n}\n\nexport const processAggregateQry = function (this: Select) {\n    const datas = this.results;\n    const datasLength = datas.length;\n    const results = {};\n    let columnToAggregate;\n\n    const getCount = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate] ? 1 : 0;\n        }\n        return result;\n    };\n    const getMax = () => {\n        let result = 0;\n        for (const i in datas) {\n            result = result > datas[i][columnToAggregate] ?\n                result : datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getMin = () => {\n        let result = Infinity, value = Infinity;\n        for (const i in datas) {\n            value = datas[i][columnToAggregate] ?\n                datas[i][columnToAggregate] : Infinity;\n            result = result < value ? result : value;\n        }\n        return result;\n    };\n    const getSum = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getAvg = () => {\n        return getSum() / datasLength;\n    };\n    const aggregateQry = this.query.aggregate;\n    for (const prop in aggregateQry) {\n        const aggregateColumn = aggregateQry[prop];\n        const aggregateValType = getDataType(aggregateColumn);\n        let aggregateCalculator;\n        switch (prop) {\n            case 'count':\n                aggregateCalculator = getCount; break;\n            case 'max':\n                aggregateCalculator = getMax; break;\n            case 'min':\n                aggregateCalculator = getMin; break;\n            case 'sum':\n                aggregateCalculator = getSum; break;\n            case 'avg':\n                aggregateCalculator = getAvg;\n        }\n        switch (aggregateValType) {\n            case DATA_TYPE.String:\n                columnToAggregate = aggregateColumn;\n                results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                break;\n            case DATA_TYPE.Array:\n                for (const key in aggregateColumn) {\n                    columnToAggregate = aggregateColumn[key];\n                    results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                }\n        }\n    }\n\n    // add results to the first index of result\n    for (const prop in results) {\n        datas[0][prop] = results[prop];\n    }\n    this.results = [datas[0]];\n}","import { OCCURENCE } from \"@/common\";\n\nexport const getRegexFromLikeExpression = (likeExpression: string) => {\n    const filterValues = likeExpression.split('%');\n    let filterValue: string;\n    let occurence: OCCURENCE;\n    if (filterValues[1]) {\n        filterValue = filterValues[1];\n        occurence = filterValues.length > 2 ? OCCURENCE.Any : OCCURENCE.Last;\n    }\n    else {\n        filterValue = filterValues[0];\n        occurence = OCCURENCE.First;\n    }\n    switch (occurence) {\n        case OCCURENCE.First:\n            return new RegExp(`^${filterValue}`, 'i');\n        case OCCURENCE.Last:\n            return new RegExp(`${filterValue}$`, 'i');\n        default:\n            return new RegExp(`${filterValue}`, 'i');\n    }\n}","import { getDataType } from \"./get_data_type\";\n\nconst isObject = (value) => {\n    return getDataType(value) === 'object' && !(value instanceof RegExp);\n};\n\nexport const clone = (obj) => {\n    if (isObject(obj)) {\n        const copy = {};\n        for (const i in obj) {\n            copy[i] = obj[i] != null && isObject(obj[i]) ? clone(obj[i]) : obj[i];\n        }\n        return copy;\n    }\n    return obj;\n};","import { getDataType } from \"./get_data_type\"\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\n\nexport const compare = (value, compareValue, symbol?) => {\n    const type1 = getDataType(value);\n    const type2 = getDataType(compareValue);\n\n    if (type1 !== type2) return false;\n    if (type1 === DATA_TYPE.DateTime) {\n        value = value.getTime();\n        compareValue = compareValue.getTime();\n    }\n    switch (symbol) {\n        // greater than\n        case QUERY_OPTION.GreaterThan:\n            return value > compareValue;\n        // less than\n        case QUERY_OPTION.LessThan:\n            return value < compareValue;\n        // less than equal\n        case QUERY_OPTION.LessThanEqualTo:\n            return value <= compareValue;\n        // greather than equal\n        case QUERY_OPTION.GreaterThanEqualTo:\n            return value >= compareValue;\n        // Not equal to\n        case QUERY_OPTION.NotEqualTo:\n            return value !== compareValue;\n        default:\n            return value === compareValue;\n    }\n}","import { QUERY_OPTION } from \"@/common\";\nimport { getDataType, clone, compare, getRegexFromLikeExpression } from \"@worker/utils\";\n\n/**\n * For matching the different column value existance for where option\n * \n * @export\n * @class WhereChecker\n */\nexport class WhereChecker {\n  where: object;\n  checkFlag: boolean;\n\n  constructor(where: object, checkFlag: boolean) {\n    this.where = clone(where);\n    this.checkFlag = checkFlag;\n  }\n\n  remove(props: string[]) {\n    const last = props.pop();\n    const value = props.reduce((prev, curr) => prev && prev[curr], this.where);\n    delete value[last];\n  }\n\n  check(rowValue) {\n    let status = true;\n    if (!this.checkFlag) return status;\n    for (let columnName in this.where) {\n      if (!status) {\n        return status;\n      }\n      const whereColumnValue = this.where[columnName];\n      const columnValue = rowValue[columnName];\n      if (getDataType(whereColumnValue) === \"object\") {\n        for (const key in whereColumnValue) {\n          if (!status) {\n            return status;\n          }\n          switch (key) {\n            case QUERY_OPTION.In:\n              status = this.checkIn(columnName, columnValue);\n              break;\n            case QUERY_OPTION.Like:\n              status = this.checkLike_(columnName, columnValue);\n              break;\n            case QUERY_OPTION.Regex:\n              status = this.checkRegex(columnName, columnValue);\n              break;\n            case QUERY_OPTION.Between:\n            case QUERY_OPTION.GreaterThan:\n            case QUERY_OPTION.LessThan:\n            case QUERY_OPTION.GreaterThanEqualTo:\n            case QUERY_OPTION.LessThanEqualTo:\n            case QUERY_OPTION.NotEqualTo:\n              status = this.checkComparisionOp_(columnName, columnValue, key);\n              break;\n            default:\n              status = false;\n          }\n        }\n      }\n      else {\n        status = compare(whereColumnValue, columnValue);\n      }\n    }\n    return status;\n  }\n\n  private checkIn(column, value) {\n    return (this.where[column][QUERY_OPTION.In] as any[]).find(q => compare(q, value)) != null;\n  }\n\n  private checkLike_(column, value) {\n    return getRegexFromLikeExpression(this.where[column][QUERY_OPTION.Like]).test(value);\n  }\n\n  private checkRegex(column, value) {\n    return this.where[column][QUERY_OPTION.Regex].test(value);\n  }\n\n  private checkComparisionOp_(column, value, symbol) {\n    const compareValue = this.where[column][symbol];\n    if (symbol != QUERY_OPTION.Between) {\n      return compare(value, compareValue, symbol);\n    }\n    return compare(value, compareValue.low, '>=') &&\n      compare(value, compareValue.high, '<=');\n  }\n}","import { Base } from \"./base\";\nimport { ISelectQuery, QUERY_OPTION, ERROR_TYPE } from \"@/common\";\nimport { getRegexFromLikeExpression, promiseReject } from \"@worker/utils\";\nimport { LogHelper, getObjectFirstKey, getDataType, getLength } from \"@worker/utils\";\nimport { WhereChecker } from \"./where_checker\";\nimport { executeWhereLogic } from \"./select/where\";\nimport { executeInLogic } from \"./select/in\";\nimport { executeRegexLogic } from \"./select/regex\";\n\nexport class BaseFetch extends Base {\n    query: ISelectQuery;\n    whereChecker: WhereChecker;\n    executeWhereLogic: typeof executeWhereLogic;\n    skipRecord;\n    limitRecord;\n    limitAtEnd = false;\n    skipAtEnd = false;\n    executeInLogic: typeof executeInLogic;\n    executeRegexLogic: typeof executeRegexLogic;\n\n    resultCount: number;\n\n    protected shouldAddValue: (value) => boolean;\n    protected goToWhereLogic() {\n        const query = this.query as ISelectQuery;\n        const whereQuery = query.where;\n        let firstColumn = (() => {\n            for (const key in whereQuery) {\n                if (this.objectStore.indexNames.contains(key)) {\n                    return key;\n                }\n            }\n        })();\n        if (firstColumn == null) {\n            firstColumn = getObjectFirstKey(whereQuery);\n            if (!query.store) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.NoIndexFound, { column: firstColumn })\n                );\n            }\n        }\n        const value = whereQuery[firstColumn];\n        if (getDataType(value) === 'object') {\n            const checkFlag = getLength(value) > 1 ||\n                getLength(whereQuery) > 1\n\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            const key = getObjectFirstKey(value);\n            this.whereChecker.remove([firstColumn, key]);\n            switch (key) {\n                case QUERY_OPTION.Like: {\n                    const regexVal = getRegexFromLikeExpression(value[QUERY_OPTION.Like]);\n                    return this.executeRegexLogic(firstColumn, regexVal);\n                }\n                case QUERY_OPTION.Regex:\n                    return this.executeRegexLogic(firstColumn, value[QUERY_OPTION.Regex]);\n                case QUERY_OPTION.In:\n                    return this.executeInLogic(\n                        firstColumn, value[QUERY_OPTION.In]\n                    );\n                case QUERY_OPTION.Between:\n                case QUERY_OPTION.GreaterThan:\n                case QUERY_OPTION.LessThan:\n                case QUERY_OPTION.GreaterThanEqualTo:\n                case QUERY_OPTION.LessThanEqualTo:\n                    return this.executeWhereLogic(firstColumn, value, key, \"next\");\n                case QUERY_OPTION.Aggregate: break;\n                default:\n                    return this.executeWhereLogic(firstColumn, value, null, \"next\");\n            }\n        }\n        else {\n            const checkFlag = getLength(whereQuery) > 1;\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            this.whereChecker.remove([firstColumn]);\n            return this.executeWhereLogic(firstColumn, value, null, \"next\");\n        }\n    }\n\n}","import { BaseFetch } from \"../base_fetch\";\nimport { Select } from \".\";\nimport { promise } from \"@/common\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\n\n\nexport const executeRegexLogic = function (this: BaseFetch, column, exp: RegExp) {\n\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n\n    const cursorRequest = this.objectStore.index(column).openCursor();\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n    })\n\n}\n\nexport const executeSkipAndLimitForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (this.results.length !== this.limitRecord && cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush(cursor.value);\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeSkipForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush((cursor.value));\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\n\n\n\n","import { Select } from \"./\";\nimport { IJoinQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, IErrorType } from \"@/common\";\nimport { getDataType, LogHelper, removeSpace, promiseReject, getKeys, getLength } from \"@/worker/utils\";\nimport { WhereChecker } from \"@executors/where_checker\";\n\n\nexport const executeJoinQuery = function (this: Select) {\n    return new Join(this).execute();\n}\n\ninterface JoinQueryWithInfo extends IJoinQuery {\n    joinTableInfo: JoinTableInfo\n}\n\nclass Join {\n\n    private joinQueryStack_: JoinQueryWithInfo[] = [];\n    private currentQueryStackIndex_ = 0;\n    tablesFetched = [];\n    results = [];\n\n    select: Select;\n    constructor(select: Select) {\n        this.select = select;\n    }\n\n    get query() {\n        return this.select.query;\n    }\n\n    getTable(name: string) {\n        return this.select.table(name);\n    }\n\n    private executeSelect(query: ISelectQuery) {\n        // this.select.util.emptyTx();\n        return new Select(query, this.select.util).\n            execute();\n    }\n\n    execute() {\n        const query = this.query;\n        this.joinQueryStack_ = getDataType(query.join) === DATA_TYPE.Object ?\n            [query.join as JoinQueryWithInfo] : query.join as JoinQueryWithInfo[];\n        // get the data for first table\n        const tableName = query.from;\n        const tablesToFetch = [];\n        if (tableName) {\n            tablesToFetch.push(tableName);\n        }\n        const joinQueryStack = this.joinQueryStack_;\n        for (let i = 0, length = joinQueryStack.length; i < length; i++) {\n            const item = joinQueryStack[i];\n            let jointblInfo = this.getJoinTableInfo_(item.on);\n            // table 1 is fetched & table2 needs to be fetched for join\n            if (item.with === jointblInfo.table1.table) {\n                jointblInfo = {\n                    table1: jointblInfo.table2,\n                    table2: jointblInfo.table1\n                };\n            }\n\n            const err = this.checkJoinQuery_(jointblInfo, item);\n            if (err) {\n                return promiseReject(err);\n            }\n            joinQueryStack[i].joinTableInfo = jointblInfo;\n            if (item.with) {\n                tablesToFetch.push(item.with)\n            }\n        }\n\n        if (!this.select.isTxQuery && tablesToFetch.length > 0) {\n            this.select.util.createTransaction(tablesToFetch);\n        }\n\n        return this.executeSelect({\n            from: tableName,\n            where: query.where,\n            case: query.case,\n            flatten: query.flatten,\n            store: query.store,\n            meta: query.meta\n        }).then(results => {\n            this.results = results.map((item) => {\n                return {\n                    [this.currentQueryStackIndex_]: item\n                };\n            });\n            this.tablesFetched.push(\n                joinQueryStack[0].joinTableInfo.table1.table\n            );\n            return this.startExecutingJoinLogic_();\n        });\n    }\n\n    private onJoinQueryFinished_() {\n        if (this.results.length === 0) return;\n        const selectApi = this.select;\n        try {\n            let results = [];\n            const tables = getKeys(this.results[0]);\n            const tablesLength = tables.length;\n            this.results.forEach((result) => {\n                let data = result[\"0\"]; // first table data\n                for (let i = 1; i < tablesLength; i++) {\n                    data = { ...data, ...result[i] };\n                }\n                results.push(data);\n            });\n            selectApi['results'] = results;\n            selectApi.setLimitAndSkipEvaluationAtEnd_();\n            selectApi.query.flatten = null;\n            if (process.env.NODE_ENV !== 'production') {\n                try {\n                    selectApi.processOrderBy();\n                }\n                catch (ex) {\n                    return promiseReject(\n                        new LogHelper((ERROR_TYPE as IErrorType).InvalidOrderQuery, ex.message)\n                    );\n                }\n            }\n            else {\n                selectApi.processOrderBy();\n            }\n        }\n        catch (ex) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n            );\n        }\n    }\n\n    private startExecutingJoinLogic_() {\n        const joinQuery = this.joinQueryStack_[this.currentQueryStackIndex_];\n        if (joinQuery) {\n            try {\n                let jointblInfo = joinQuery.joinTableInfo;\n                return this.executeSelect({\n                    from: joinQuery.with,\n                    where: joinQuery.where,\n                    case: joinQuery.case,\n                    flatten: joinQuery.flatten,\n                    store: joinQuery.store,\n                    meta: joinQuery.meta\n                }).then(results => {\n                    this.jointables(joinQuery, jointblInfo, results);\n                    this.tablesFetched.push(jointblInfo.table2.table);\n                    ++this.currentQueryStackIndex_;\n                    return this.startExecutingJoinLogic_();\n                });\n            }\n            catch (ex) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n                );\n            }\n        }\n        else {\n            return this.onJoinQueryFinished_();\n        }\n    }\n\n    private jointables(joinQuery: JoinQueryWithInfo, jointblInfo: JoinTableInfo, secondtableData: any[]) {\n        const joinType = joinQuery.type;\n        const output = [];\n        const column1 = jointblInfo.table1.column;\n        const column2 = jointblInfo.table2.column;\n        const table1Index = this.tablesFetched.indexOf(jointblInfo.table1.table);\n        const table2Index = this.currentQueryStackIndex_ + 1;\n        const asQuery = joinQuery.as;\n        const mapWithAlias = asQuery ? (value: object) => {\n            for (const key in asQuery) {\n                const asValue = asQuery[key];\n                if (value[asValue] === undefined) {\n                    value[asValue] = value[key];\n                    delete value[key];\n                }\n            }\n            return value;\n        } : (val) => val;\n        const performInnerJoin = () => {\n            let index = 0;\n            this.results.forEach(valueFromFirstTable => {\n                secondtableData.forEach((valueFromSecondTable) => {\n                    if (valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2]) {\n                        output[index] = { ...valueFromFirstTable };\n                        output[index++][table2Index] = mapWithAlias({ ...valueFromSecondTable });\n                    }\n                });\n            });\n        };\n        const performleftJoin = () => {\n            let index = 0;\n            let valueMatchedFromSecondTable: any[];\n            let callBack;\n            const columnDefaultValue = {};\n            const nullValue = null;\n            if (joinQuery.store) {\n                getKeys(joinQuery.store).forEach(columnName => {\n                    columnDefaultValue[columnName] = nullValue;\n                })\n            }\n            else {\n                this.getTable(jointblInfo.table2.table).columns.forEach(col => {\n                    columnDefaultValue[col.name] = nullValue;\n                });\n            }\n\n            if (table2Index === 1) {\n                callBack = function (valueFromSecondTable, valueFromFirstTable) {\n                    if (valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2]) {\n                        valueMatchedFromSecondTable.push(valueFromSecondTable);\n                    }\n                };\n            }\n            else {\n                callBack = function (valueFromSecondTable, valueFromFirstTable) {\n                    const value = valueFromFirstTable[table1Index];\n                    if (value != null && value[column1] === valueFromSecondTable[column2]) {\n                        valueMatchedFromSecondTable.push(valueFromSecondTable);\n                    }\n                };\n            }\n            const whereQry = Object.assign(joinQuery.where || {}, joinQuery['whereJoin'] || {});\n            const whereCheker = new WhereChecker(whereQry, getLength(whereQry) > 0);\n            this.results.forEach((valueFromFirstTable) => {\n                valueMatchedFromSecondTable = [];\n                // perform left join\n                secondtableData.forEach(val => {\n                    callBack(val, valueFromFirstTable)\n                });\n\n                if (valueMatchedFromSecondTable.length === 0) {\n                    valueMatchedFromSecondTable = [columnDefaultValue];\n                }\n\n                valueMatchedFromSecondTable.forEach(function (value) {\n                    value = mapWithAlias(value);\n                    if (!whereCheker.check(value)) return;\n\n                    output[index] = { ...valueFromFirstTable };\n                    output[index++][table2Index] = value;\n                });\n            });\n        };\n        switch (joinType) {\n            case \"left\":\n                performleftJoin(); break;\n            default:\n                performInnerJoin();\n        }\n        this.results = output;\n    }\n\n    private getJoinTableInfo_(joinOn: string) {\n        joinOn = removeSpace(joinOn);\n        const splittedjoinOn = joinOn.split(\"=\");\n        const splittedjoinOnbydotFirst = splittedjoinOn[0].split(\".\");\n        const splittedjoinOnbydotSecond = splittedjoinOn[1].split(\".\");\n        const info = {\n            table1: {\n                table: splittedjoinOnbydotFirst[0],\n                column: splittedjoinOnbydotFirst[1]\n            },\n            table2: {\n                table: splittedjoinOnbydotSecond[0],\n                column: splittedjoinOnbydotSecond[1]\n            }\n        } as JoinTableInfo;\n        return info;\n    }\n\n    private checkJoinQuery_(jointblInfo: JoinTableInfo, qry: IJoinQuery) {\n        if (qry.store) return null;\n\n        const table1 = jointblInfo.table1;\n        const table2 = jointblInfo.table2;\n        const tableSchemaOf1stTable = this.getTable(table1.table);\n        const tableSchemaOf2ndTable = this.getTable(table2.table);\n        let err: LogHelper;\n        // check on info & with info \n        if (qry.with !== table2.table) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `on value should contains value of with`\n            );\n        }\n\n        // check for column existance\n        if (tableSchemaOf1stTable.columns.find(q => q.name === table1.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table1.column} does not exist in table ${table1.table}`\n            );\n        }\n        else if (tableSchemaOf2ndTable.columns.find(q => q.name === table2.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table2.column} does not exist in table ${table2.table}`\n            );\n        }\n\n        // check for column match in both table\n        if (qry.as == null) {\n            qry.as = {};\n        }\n        tableSchemaOf1stTable.columns.every(function (column) {\n            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === column.name && q.name !== table1.column);\n            if (columnFound != null && qry.as[columnFound.name] == null) {\n                err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `column ${column.name} exist in both table ${table1.table} & ${table2.table}`\n                );\n                return false;\n            }\n            return true;\n        });\n        const whereQry = qry.where;\n        if (whereQry) {\n            const whereJoin = {};\n            for (const key in whereQry) {\n                // const whereQueryVal = whereQry[key];\n                const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === key);\n                if (!columnFound) {\n                    whereJoin[key] = whereQry[key];\n                    delete whereQry[key];\n                }\n            }\n            qry['whereJoin'] = whereJoin;\n            if (getLength(whereQry) === 0) {\n                qry.where = null;\n            }\n        }\n        return err;\n    }\n}\n\ntype JoinTableInfo = {\n    table1: { table: string, column: string }\n    table2: { table: string, column: string }\n};","import { promiseResolve } from \"@/common\";\nimport { getKeys } from \"../utils\";\n\nexport class MemoryObjectStore {\n    data: any[];\n\n    constructor(data: any[]) {\n        this.data = data;\n    }\n\n    get indexNames() {\n        const keys = getKeys(this.data[0])\n        return {\n            contains(columnName: string) {\n                return keys.indexOf(columnName) >= 0;\n            }\n        }\n    }\n\n    index(column: string) {\n        return {\n            openCursor: (keyRange?: IDBKeyRange) => {\n                const cursorRequest = {\n\n                } as {\n                    onsuccess: Function,\n                    onerror: Function\n                }\n                let index = 0;\n                const cursor = {\n                    continue() {\n                        ++index;\n                        execute();\n                    },\n                }\n                const callOnSuccess = (result) => {\n                    cursorRequest.onsuccess({\n                        target: {\n                            result\n                        }\n                    });\n                }\n                const execute = () => {\n                    const value = this.data[index];\n                    if (value) {\n                        const columnValue = value[column];\n                        if (columnValue && (keyRange == null || keyRange.includes(columnValue))) {\n                            (cursor as any).key = columnValue;\n                            (cursor as any).value = value;\n                            callOnSuccess(cursor)\n                        }\n                        else {\n                            cursor.continue();\n                        }\n                    }\n                    else {\n                        callOnSuccess(null);\n                    }\n                }\n                promiseResolve().then(execute);\n                return cursorRequest;\n            }\n        }\n    }\n}","import { ISelectQuery, QUERY_OPTION, IDB_MODE, API, IWhereQuery, promiseResolve, IOrderQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { isArray, isObject, getObjectFirstKey, promiseReject, getLength } from \"@/worker/utils\";\nimport { setPushResult, setLimitAndSkipEvaluationAtEnd, removeDuplicates } from \"./base_select\";\nimport { ThenEvaluator } from \"./then_evaluator\";\nimport { executeWhereUndefinedLogic } from \"./not_where\"\nimport { processAggregateQry, processGroupDistinctAggr, processOrderBy } from \"./order_by\";\nimport { executeAggregateGroupBy, processGroupBy } from \"./group_by\";\nimport { executeWhereLogic } from \"./where\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeJoinQuery } from \"./join\";\nimport { MemoryObjectStore } from \"@/worker/memory_store\";\n\nexport class Select extends BaseFetch {\n    sorted = false;\n    isOr: boolean;\n    isArrayQry: boolean;\n    query: ISelectQuery;\n    orInfo: {\n        results?: any[];\n        orQuery: object\n    };\n\n    isSubQuery = false;\n\n    protected pushResult: (value) => void;\n\n    protected thenEvaluator = new ThenEvaluator();\n\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    setLimitAndSkipEvaluationAtEnd_: typeof setLimitAndSkipEvaluationAtEnd\n    setPushResult: typeof setPushResult;\n    removeDuplicates: typeof removeDuplicates;\n    executeJoinQuery: typeof executeJoinQuery\n    processGroupDistinctAggr: typeof processGroupDistinctAggr;\n    processOrderBy: typeof processOrderBy;\n    processAggregateQry: typeof processAggregateQry;\n    executeAggregateGroupBy: typeof executeAggregateGroupBy;\n    processGroupBy: typeof processGroupBy;\n\n\n    constructor(query: ISelectQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n        this.setPushResult();\n        if (isArray(query.where)) {\n            this.isArrayQry = true;\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else {\n            this.skipRecord = query.skip;\n            this.limitRecord = query.limit;\n        }\n        const orderQuery = query.order;\n        if (orderQuery) {\n            if (isArray(orderQuery) || (orderQuery as IOrderQuery).case || isObject((orderQuery as IOrderQuery).by)) {\n                ((orderQuery as IOrderQuery).idbSorting) = false;\n            }\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else if (query.groupBy) {\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n    }\n\n    execute(beforeExecute?: () => Promise<any>): Promise<any> {\n        let pResult: Promise<void>;\n        if (!beforeExecute) {\n            beforeExecute = () => promiseResolve(null);\n        }\n        const query = this.query;\n        try {\n            const err = new QueryHelper(this.db).validate(API.Select, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if (isArray(query.where)) {\n                            pResult = this.processWhereArrayQry();\n                        }\n                        else {\n                            pResult = this.processWhere_();\n                        }\n                    }\n                    else {\n                        pResult = this.executeWhereUndefinedLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeJoinQuery();\n                }\n                return pResult.then(\n                    this.returnResult_.bind(this)\n                )\n            })\n\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private processWhereArrayQry() {\n        this.isArrayQry = true;\n        const whereQuery = this.query.where as IWhereQuery[];\n        const pKey = this.primaryKey();\n        let isFirstWhere = true, output = [], operation;\n\n        const isItemExist = (keyValue) => {\n            return output.findIndex(item => item[pKey] === keyValue) >= 0;\n        };\n        const onSuccess = () => {\n            if (operation === QUERY_OPTION.And) {\n                const doAnd = () => {\n                    let andResults = [];\n                    this.results.forEach((item) => {\n                        if (isItemExist(item[pKey])) {\n                            andResults.push(item);\n                        }\n                    });\n                    output = andResults;\n                    andResults = null;\n                };\n\n                if (isFirstWhere === true) {\n                    output = this.results;\n                }\n                else if (output.length > 0) {\n                    doAnd();\n                }\n            }\n            else {\n                if (output.length > 0) {\n                    this.results = [...output, ...this.results];\n                    this.removeDuplicates();\n                    output = this.results;\n                }\n                else {\n                    output = this.results;\n                }\n            }\n            isFirstWhere = false;\n            if (whereQuery.length > 0) {\n                this.results = [];\n                return processFirstQry();\n            }\n            else {\n                this.results = output;\n            }\n\n        };\n        const processFirstQry = () => {\n            let whereQueryToProcess = whereQuery.shift();\n            if (whereQueryToProcess[QUERY_OPTION.Or]) {\n                if (getLength(whereQueryToProcess) === 1) {\n                    operation = QUERY_OPTION.Or;\n                    whereQueryToProcess = whereQueryToProcess[QUERY_OPTION.Or] as any;\n                }\n                else {\n                    operation = QUERY_OPTION.And;\n                }\n            }\n            else {\n                operation = QUERY_OPTION.And;\n            }\n            this.query.where = whereQueryToProcess;\n            return this.processWhere_().then(onSuccess);\n        };\n        return processFirstQry();\n    }\n\n    private initTransaction_() {\n        const store = this.query.store\n        if (store) {\n            this.objectStore = new MemoryObjectStore(store as any[]) as any;\n            return\n        }\n        if (!this.isTxQuery) {\n            this.util.createTransactionIfNotExist([this.tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(this.tableName);\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (cursor: IDBCursorWithValue) => {\n            return this.whereChecker.check(cursor.value);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic_();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        })\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private returnResult_ = () => {\n        if (this.results.length > 0) {\n            const query = this.query;\n            if (query.flatten) {\n                const flattendData = [];\n                const indexToDelete = new Map<number, Boolean>();\n                query.flatten.forEach(column => {\n                    this.results.forEach((data, i) => {\n                        data[column].forEach(item => {\n                            flattendData.push(\n                                { ...data, ...{ [column]: item } }\n                            );\n                        });\n                        indexToDelete.set(i, true);\n                    });\n                });\n                let itemsDeleted = 0;\n                indexToDelete.forEach((_, key) => {\n                    this.results.splice(key - itemsDeleted, 1);\n                    ++itemsDeleted;\n                });\n                this.results = this.results.concat(flattendData);\n            }\n            this.processGroupDistinctAggr();\n            this.processOrderBy();\n            if (this.skipAtEnd) {\n                this.results.splice(0, query.skip);\n            }\n            if (this.limitAtEnd) {\n                this.results = this.results.slice(0, query.limit);\n            }\n        }\n        return this.results;\n    }\n\n    private orQueryFinish_() {\n        this.isOr = false;\n        this.results = this.orInfo.results;\n        // free or info memory\n        this.orInfo = null;\n        this.removeDuplicates();\n        // this.onQueryFinished();\n    }\n\n    private orQuerySuccess_() {\n        const query = this.query;\n        if (this.results.length > 0) {\n            this.orInfo.results = [... this.orInfo.results, ...this.results];\n        }\n\n        this.results = [];\n        const key = getObjectFirstKey(this.orInfo.orQuery);\n        if (key != null) {\n            const where = {};\n            where[key] = this.orInfo.orQuery[key];\n            delete this.orInfo.orQuery[key];\n            query.where = where;\n            return this.goToWhereLogic().then(this.onWhereEvaluated.bind(this))\n        }\n        return this.orQueryFinish_();\n    }\n\n    private processOrLogic_() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        this.orInfo = {\n            orQuery: where.or as any,\n            results: []\n        };\n        this.setLimitAndSkipEvaluationAtEnd_();\n        // free or memory\n        delete where.or;\n    }\n}\n\nSelect.prototype.executeInLogic = executeInLogic;\nSelect.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nSelect.prototype.executeWhereLogic = executeWhereLogic;\nSelect.prototype.executeRegexLogic = executeRegexLogic;\n\nSelect.prototype.setLimitAndSkipEvaluationAtEnd_ = setLimitAndSkipEvaluationAtEnd\nSelect.prototype.setPushResult = setPushResult;\nSelect.prototype.removeDuplicates = removeDuplicates;\nSelect.prototype.executeJoinQuery = executeJoinQuery\nSelect.prototype.processGroupDistinctAggr = processGroupDistinctAggr;\nSelect.prototype.processOrderBy = processOrderBy;\nSelect.prototype.processAggregateQry = processAggregateQry;\nSelect.prototype.executeAggregateGroupBy = executeAggregateGroupBy;\nSelect.prototype.processGroupBy = processGroupBy;\n","export const isObject = (value) => {\n    return typeof value === 'object';\n};","import { Select } from \"./\";\nimport { promise, promiseAll } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\nimport { executeSkipAndLimitForWhere_, executeSkipForWhere_ } from \"./regex\";\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = this.objectStore.index(column).openCursor(\n                this.util.keyRange(value)\n            );\n            cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(runInLogic)\n    );\n\n};\n","import { Select } from \"./index\";\n\nexport const setPushResult = function (this: Select) {\n    const caseQuery = this.query.case;\n    if (caseQuery) {\n        this.pushResult = (value) => {\n            let columnName: string;\n            this.thenEvaluator.setCaseAndValue(caseQuery, value);\n            for (columnName in caseQuery) {\n                value[columnName] = this.thenEvaluator.setColumn(columnName).evaluate();\n            }\n            this.results.push(value);\n        };\n    }\n    else {\n        this.pushResult = (value) => {\n            this.results.push(value);\n        };\n    }\n}\n\nexport const setLimitAndSkipEvaluationAtEnd = function (this: Select) {\n    if (this.query.limit) {\n        this.limitAtEnd = true;\n    }\n    if (this.query.skip) {\n        this.skipAtEnd = true;\n    }\n}\n\nexport const removeDuplicates = function (this: Select) {\n    let datas = this.results;\n    const key = this.primaryKey();\n    const lookupObject = new Map();\n    for (let i = 0, len = datas.length; i < len; i++) {\n        lookupObject.set(datas[i][key], datas[i]);\n    }\n\n    this.results = Array.from(lookupObject.values());\n}","import { Select } from \".\";\nimport { getDataType, getObjectFirstKey } from \"@/worker/utils\";\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\n\nexport const processGroupBy = function (this: Select) {\n    const groupBy = this.query.groupBy as any;\n    let datas = this.results;\n    const lookUpObj = new Map<string, any>();\n\n    const groupByDataType = getDataType(groupBy);\n    if (groupByDataType !== DATA_TYPE.Object) {\n        if (groupByDataType === DATA_TYPE.String) {\n            for (const i in datas) {\n                lookUpObj.set(datas[i][groupBy as string], datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                for (const column in groupBy) {\n                    objKey += datas[i][groupBy[column]];\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n    else {\n        const caseQueryLength = Object.keys(groupBy).length;\n        if (caseQueryLength === 1) {\n            const groupByColumn = getObjectFirstKey(groupBy);\n            this.thenEvaluator.setCaseAndColumn(groupBy, groupByColumn);\n            for (const i in datas) {\n                lookUpObj.set(this.thenEvaluator.setValue(datas[i]).evaluate(), datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                this.thenEvaluator.setCaseAndValue(groupBy, datas[i]);\n                for (const column in groupBy) {\n                    objKey += this.thenEvaluator.setColumn(column).evaluate();\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n\n    this.results = Array.from(lookUpObj.values());\n}\n\nexport const executeAggregateGroupBy = function (this: Select) {\n    const grpQry = this.query.groupBy as any;\n    let datas = this.results;\n\n    const lookUpObj = new Map<string, any>();\n    // assign aggregate\n    const aggregateQry = this.query.aggregate;\n\n    let index;\n    let objKey;\n    let value;\n    let columnToAggregate;\n    const calculateAggregate = () => {\n        const getCount = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            return value;\n        };\n        const getList = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"list(\" + columnToAggregate + \")\"] : [];\n            // push value\n            value.push(datas[index][columnToAggregate]);\n            return value;\n        };\n        const getMax = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"max(\" + columnToAggregate + \")\"] : 0;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : 0;\n            // compare between old value and new value\n            return value > datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getMin = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"min(\" + columnToAggregate + \")\"] : Infinity;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : Infinity;\n            // compare between old value and new value\n            return value < datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getSum = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            return value;\n        };\n        const getAvg = () => {\n            value = lookUpObj.get(objKey)\n            // get old sum value\n            let sumOfColumn = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            sumOfColumn += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            datas[index][\"sum(\" + columnToAggregate + \")\"] = sumOfColumn;\n            // get old count value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            datas[index][\"count(\" + columnToAggregate + \")\"] = value;\n        };\n        for (const prop in aggregateQry) {\n            const aggregateColumn = aggregateQry[prop];\n            const aggregateValType = getDataType(aggregateColumn);\n            let aggregateCalculator;\n            switch (prop) {\n                case QUERY_OPTION.Count:\n                    aggregateCalculator = getCount;\n                    break;\n                case QUERY_OPTION.Max:\n                    aggregateCalculator = getMax;\n                    break;\n                case QUERY_OPTION.Min:\n                    aggregateCalculator = getMin;\n                    break;\n                case QUERY_OPTION.Sum:\n                    aggregateCalculator = getSum;\n                    break;\n                case QUERY_OPTION.Avg:\n                    aggregateCalculator = getAvg;\n                    break;\n                case QUERY_OPTION.List:\n                    aggregateCalculator = getList;\n                    break;\n            }\n            switch (aggregateValType) {\n                case DATA_TYPE.String:\n                    columnToAggregate = aggregateColumn;\n                    datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    break;\n                case DATA_TYPE.Array:\n                    for (const item in aggregateColumn) {\n                        columnToAggregate = aggregateColumn[item];\n                        datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    }\n            }\n        }\n    };\n\n    if (getDataType(grpQry) === DATA_TYPE.String) {\n        for (index in datas) {\n            objKey = datas[index][grpQry];\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n    }\n    else {\n        for (index in datas) {\n            objKey = \"\";\n            for (const column in grpQry) {\n                objKey += datas[index][grpQry[column]];\n            }\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n\n    }\n    datas = Array.from(lookUpObj.values());\n\n    // Checking for avg and if exist then fill the datas;\n    const avgQuery = aggregateQry.avg;\n    if (avgQuery) {\n        if (getDataType(avgQuery) === DATA_TYPE.String) {\n            for (index in datas) {\n                const sumForAvg = datas[index][\"sum(\" + avgQuery + \")\"],\n                    countForAvg = datas[index][\"count(\" + avgQuery + \")\"];\n                datas[index][\"avg(\" + avgQuery + \")\"] = sumForAvg / countForAvg;\n                if (aggregateQry.count !== avgQuery) {\n                    delete datas[index][\"count(\" + avgQuery + \")\"];\n                }\n                if (aggregateQry.sum !== avgQuery) {\n                    delete datas[index][\"sum(\" + avgQuery + \")\"];\n                }\n            }\n        }\n        else {\n            const isCountTypeString = getDataType(aggregateQry.count) === DATA_TYPE.String;\n            const isSumTypeString = getDataType(aggregateQry.sum) === DATA_TYPE.String;\n            for (index in datas) {\n                for (const column in avgQuery as any) {\n                    const avgColumn = avgQuery[column],\n                        sum = datas[index][\"sum(\" + avgColumn + \")\"],\n                        count = datas[index][\"count(\" + avgColumn + \")\"];\n                    datas[index][\"avg(\" + avgColumn + \")\"] = sum / count;\n\n                    if (isCountTypeString) {\n                        if (aggregateQry.count !== avgColumn) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.count.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                    }\n\n                    if (isSumTypeString) {\n                        if (aggregateQry.sum !== avgColumn) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.sum.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    this.results = datas;\n}\n","import { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { Count } from \".\";\n\nexport const executeWhereUndefinedLogic = function (this: BaseFetch) {\n    let countRequest;\n    const objectStore = this.objectStore;\n    const onSuccess = (() => {\n        if (objectStore.count) {\n            countRequest = objectStore.count();\n            return (onFinish) => {\n                return () => {\n                    (this as Count).resultCount = countRequest.result;\n                    onFinish();\n                }\n            }\n        }\n        else {\n            let cursor;\n            countRequest = objectStore.openCursor();\n            return (onFinish) => {\n                return (e: any) => {\n                    cursor = e.target.result;\n                    if (cursor) {\n                        ++(this as Count).resultCount;\n                        cursor.continue();\n                    }\n                    else {\n                        onFinish();\n                    }\n                };\n            };\n        }\n    })();\n    return promise((res, rej) => {\n        countRequest.onerror = rej;\n        countRequest.onsuccess = onSuccess(res);\n    });\n}\n","import { BaseFetch } from \"../base_fetch\";\nimport { getLength } from \"@/worker/utils\";\nimport { Count } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereCount = function (this: BaseFetch, onFinish) {\n    return (e) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                ++(this as Count).resultCount;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    }\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op) {\n    value = op ? value[op] : value;\n    let cursorRequest;\n\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n    const objectStore = this.objectStore;\n\n    return promise((res, rej) => {\n        if (isWhereKeysLengthOne && objectStore.count) {\n            cursorRequest = objectStore.index(column).count(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = () => {\n                (this as Count).resultCount = cursorRequest.result;\n                res();\n            }\n        }\n        else {\n            cursorRequest = objectStore.index(column).openCursor(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n        }\n        cursorRequest.onerror = rej;\n    });\n}","import { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { ICountQuery, ISelectQuery, IDB_MODE, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray } from \"@worker/utils\";\nimport { executeWhereUndefinedLogic } from \"@executors/count/not_where\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeInLogic } from \"./in\";\n\nexport class Count extends BaseFetch {\n\n    query: ICountQuery;\n    resultCount: number = 0;\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    constructor(query: ICountQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Count, query);\n        if (err) {\n            return promiseReject(\n                err\n            );\n        }\n        return beforeExecute().then(_ => {\n            let result: Promise<void>;\n            try {\n                const getDataFromSelect = () => {\n                    const selectInstance = new Select(query as ISelectQuery, this.util);\n                    selectInstance.isTxQuery = this.isTxQuery;\n                    return selectInstance.execute().then(results => {\n                        this.resultCount = results.length;\n                    });\n                };\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                            result = getDataFromSelect();\n                        }\n                        else {\n                            this.shouldAddValue = (cursor) => {\n                                return this.whereChecker.check(cursor.value);\n                            };\n                            result = this.goToWhereLogic();\n                        }\n                    }\n                    else {\n                        result = this.executeWhereUndefinedLogic() as any;\n                    }\n                }\n                else {\n                    result = getDataFromSelect();\n                }\n            }\n            catch (ex) {\n                this.onException(ex);\n            }\n            return result.then(_ => {\n                return this.resultCount;\n            })\n        });\n    }\n\n    private initTransaction_() {\n        const tableName = this.query.from;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nCount.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nCount.prototype.executeWhereLogic = executeWhereLogic\nCount.prototype.executeRegexLogic = executeRegexLogic\nCount.prototype.executeInLogic = executeInLogic","import { BaseFetch } from \"../base_fetch\";\nimport { promise } from \"@/common\";\nimport { onWhereCount } from \"./where\";\n\nexport const executeRegexLogic = function (this: BaseFetch, column: string, exp: RegExp) {\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onWhereCount.call(this, res);\n    })\n}","import { promise, promiseAll } from \"@/common\";\nimport { getLength } from \"@/worker/utils\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { onWhereCount } from \"./where\";\n\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    const objectStore = this.objectStore;\n    const columnStore = objectStore.index(column);\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        const keyRange = this.util.keyRange(value);\n        if (isWhereKeysLengthOne && objectStore.count) {\n            return promise((res, rej) => {\n                const cursorRequest = columnStore.count(keyRange);\n                cursorRequest.onsuccess = (e: any) => {\n                    this.resultCount += e.target.result;\n                    res();\n                };\n                cursorRequest.onerror = rej;\n            });\n        }\n        return promise<void>((res, rej) => {\n            const cursorRequest = columnStore.openCursor(keyRange);\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { isArray } from \"./is_array\";\n\nexport const variableFromPath = (path: string) => {\n    const properties: string[] = isArray(path) ? path as any : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], self);\n}","import { getDataType, variableFromPath, promiseReject, LogHelper } from \"@worker/utils\";\nimport { DATA_TYPE, ERROR_TYPE, IUpdateQuery } from \"@/common\";\n\nexport const updateValue = (query: IUpdateQuery, storedValue) => {\n    let setValue = query.set;\n    const mapSet = query.mapSet;\n    if (mapSet) {\n        const result = (mapSet as Function)(setValue, storedValue);\n        if (result != null) {\n            setValue = result;\n        }\n    }\n    for (const key in setValue) {\n        const columnSetValue = setValue[key];\n        if (getDataType(columnSetValue) !== DATA_TYPE.Object) {\n            storedValue[key] = columnSetValue;\n        }\n        else {\n            for (const op in columnSetValue) {\n                let value = columnSetValue[op];\n                switch (op as any) {\n                    case '+': storedValue[key] += value; break;\n                    case '-': storedValue[key] -= value; break;\n                    case '*': storedValue[key] *= value; break;\n                    case '/': storedValue[key] /= value; break;\n                    case '{push}': storedValue[key].push(value); break;\n                    default: storedValue[key] = columnSetValue;\n                }\n                break;\n            }\n        }\n    }\n    return storedValue;\n};","import { IUpdateQuery, ISelectQuery, QUERY_OPTION, API, IWhereQuery, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { DbMeta } from \"@worker/model\";\nimport { QueryHelper } from \"../query_helper\";\nimport { promiseReject, isArray, getDataType, variableFromPath, LogHelper } from \"@worker/utils\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeWhereLogic } from \"./where\";\n\nexport class Update extends BaseFetch {\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic\n\n    constructor(query: IUpdateQuery, util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n        this.tableName = query.in;\n        const mapSet = query.mapSet;\n        if (mapSet) {\n            const method = getDataType(mapSet) === DATA_TYPE.String ?\n                variableFromPath(mapSet as string) : mapSet;\n            if (!method) {\n                throw new LogHelper(ERROR_TYPE.MethodNotExist, mapSet);\n            }\n            query.mapSet = method;\n        }\n\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const query: IUpdateQuery = this.query as any;\n        try {\n            const queryHelper = new QueryHelper(this.db);\n            const err = queryHelper.validate(API.Update, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction();\n                let pResult: Promise<void>;\n                if (query.where != null) {\n                    if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                        pResult = this.executeComplexLogic_();\n                    }\n                    else {\n                        pResult = this.goToWhereLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n                return pResult.then(() => {\n                    return this.rowAffected;\n                })\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private executeComplexLogic_() {\n        const query: IUpdateQuery = this.query as any;\n        const selectObject = new Select({\n            from: query.in,\n            where: query.where,\n            ignoreCase: query.ignoreCase\n        } as ISelectQuery, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results: any[]) => {\n            const key = this.primaryKey(query.in);\n            const inQuery = [];\n            results.forEach((value) => {\n                inQuery.push(value[key]);\n            });\n            results = null;\n            const whereQry = { [key]: { [QUERY_OPTION.In]: inQuery } };\n            this.query.where = whereQry;\n            this.initTransaction();\n            return this.goToWhereLogic();\n        });\n    }\n\n    private initTransaction() {\n        const tableName = (this.query as any).in;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName]);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nUpdate.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nUpdate.prototype.executeWhereLogic = executeWhereLogic\nUpdate.prototype.executeRegexLogic = executeRegexLogic\nUpdate.prototype.executeInLogic = executeInLogic","import { Update } from \"./\";\nimport { promise } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeWhereUndefinedLogic = function (this: Update) {\n    const cursorRequest: IDBRequest<IDBCursorWithValue> = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = (e as any).target.result;\n            if (cursor) {\n                try {\n                    const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                    cursorUpdateRequest.onsuccess = () => {\n                        ++this.rowAffected;\n                        cursor.continue();\n                    };\n                    cursorUpdateRequest.onerror = rej;\n                } catch (ex) {\n                    rej(\n                        ex\n                    );\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\nimport { Update } from \"./\";\n\nexport const executeWhereLogic = function (this: Update, column, value, op) {\n    const query: IUpdateQuery = this.query as any;\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = e.target.result;\n            if (cursor) {\n                if (this.whereChecker.check(cursor.value)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(query, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej\n    })\n}","import { Update } from \"./\";\nimport { updateValue } from \"./update_value\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Update, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorOpenRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n\n        cursorOpenRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n\n            }\n            else {\n                res();\n            }\n        };\n        cursorOpenRequest.onerror = rej;\n    })\n\n}\n","import { Update } from \"./\";\nimport { promiseAll, promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeInLogic = function (this: Update, column, values: any[]) {\n    const columnStore = this.objectStore.index(column);\n    const query: IUpdateQuery = this.query as any;\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnStore.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = (e: any) => {\n                const cursor: IDBCursorWithValue = e.target.result;\n                if (cursor) {\n                    const value = cursor.value;\n                    if (this.whereChecker.check(value)) {\n                        try {\n                            const cursorUpdateRequest = cursor.update(updateValue(query, value));\n                            cursorUpdateRequest.onsuccess = () => {\n                                ++this.rowAffected;\n                                cursor.continue();\n                            };\n                            cursorUpdateRequest.onerror = rej;\n                        }\n                        catch (ex) {\n                            rej(\n                                ex\n                            );\n                        }\n\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    res();\n                }\n            };\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { IIntersectQuery, ISelectQuery } from \"@/common\";\nimport { Base } from \"@executors/base\";\nimport { Select } from \"@executors/select\";\n\nexport class Intersect extends Base {\n\n    constructor(intersectQry: IIntersectQuery, util) {\n        super();\n        this.query = intersectQry as any;\n        this.util = util;\n    }\n\n    execute() {\n        const intersectQry: IIntersectQuery = this.query as any;\n        let index = 0;\n        let hashMap = {};\n        let hashMapTemp = {};\n        let isQueryForSameTable = true;\n        const queries = intersectQry.queries;\n        const queryLength = queries.length;\n        queries.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== queries[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(queries[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n\n        let select: Select;\n        const fetchData = () => {\n            if (index < queryLength) {\n                select = new Select(queries[index], this.util);\n                return select.execute().then((selectResult) => {\n                    hashMap = {};\n                    selectResult.forEach(val => {\n                        const columnValKey = getHashKey(val);\n                        if (index === 0) {\n                            hashMapTemp[columnValKey] = val;\n                        } else if (hashMapTemp[columnValKey] != null) {\n                            hashMap[columnValKey] = val;\n                        }\n                    });\n                    if (index > 0) {\n                        hashMapTemp = { ...hashMap };\n                    }\n\n                    ++index;\n                    return fetchData();\n                })\n            }\n            else {\n                const results = [];\n                let resultPusher: (key: string) => void;\n                let skip = intersectQry.skip;\n                const limit = intersectQry.limit;\n                const onFinished = () => {\n                    select['results'] = results;\n                    Object.assign(select.query, {\n                        order: intersectQry.order,\n                        join: {} as any\n                    } as ISelectQuery);\n                    select.processOrderBy();\n                    select.processGroupDistinctAggr();\n                    return (select['results']);\n                };\n                let shouldStopLoop = false;\n                let key: string;\n                const pushResult = () => {\n                    results.push(hashMap[key]);\n                };\n                const checkLimitAndPush = () => {\n                    if (results.length < limit) {\n                        pushResult();\n                    }\n                    else {\n                        shouldStopLoop = true;\n                    }\n                };\n                const skipChecker = (callBack: () => void) => {\n                    if (skip === 0) {\n                        callBack();\n                    }\n                    else {\n                        --skip;\n                    }\n                };\n                if (intersectQry.skip && intersectQry.limit) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            checkLimitAndPush();\n                        });\n                    };\n\n                }\n                else if (intersectQry.limit) {\n                    resultPusher = checkLimitAndPush;\n                }\n                else if (intersectQry.skip) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            pushResult();\n                        });\n                    };\n                }\n                else {\n                    resultPusher = () => {\n                        pushResult();\n                    };\n                }\n                if (limit) {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                        if (shouldStopLoop) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                    }\n                }\n                return onFinished();\n            }\n        };\n        return fetchData();\n    }\n}","import { LogHelper, getError } from \"@worker/utils\";\nimport { ERROR_TYPE, promise } from \"@/common\";\n\nexport class DropDb {\n\n    execute(dbName: string) {\n        return promise((res, rej) => {\n            const dropDbRequest = indexedDB.deleteDatabase(dbName);\n            dropDbRequest.onblocked = () => {\n                const err = new LogHelper(ERROR_TYPE.DbBlocked);\n                return rej(\n                    getError(err)\n                );\n            };\n            dropDbRequest.onerror = (e) => {\n                return rej(\n                    getError(e)\n                )\n            };\n            dropDbRequest.onsuccess = () => {\n                res();\n            };\n        })\n    }\n}\n","import { Base } from \"@executors/base\";\nimport { ISelectQuery } from \"@/common\";\nimport { Select } from \"@executors/select\";\nimport { IDBUtil } from \"@/worker/idbutil\";\n\nexport class Union extends Base {\n\n    constructor(query: ISelectQuery[], util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n    }\n\n    execute() {\n        const query: ISelectQuery[] = this.query as any;\n        let index = 0;\n        const hashMap = new Map();\n        let isQueryForSameTable = true;\n        const queryLength = query.length;\n        query.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== query[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(query[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n        let select: Select;\n        const fetchData = () => {\n            if (index < query.length) {\n                select = new Select(query[index++], this.util);\n                return select.execute().then((selectResult) => {\n                    selectResult.forEach(val => {\n                        hashMap.set(getHashKey(val), val);\n                    });\n                    return fetchData();\n                })\n            }\n            else {\n                return Array.from(hashMap.values());\n            }\n        };\n        return fetchData();\n    }\n\n\n}","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereRemove = function (this: Remove, onFinish) {\n    return (e) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor.value)) {\n                cursor.delete();\n                ++this.rowAffected;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeWhereLogic = function (this: Remove, column, value, op) {\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = onWhereRemove.call(this, res);\n        cursorRequest.onerror = rej\n    })\n\n}\n\n","import { BaseFetch } from \"../base_fetch\";\nimport { IRemoveQuery, QUERY_OPTION, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray, getObjectFirstKey } from \"@/worker/utils\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\n\nexport class Remove extends BaseFetch {\n    isOr;\n    executeWhereUndefinedLogic;\n\n    constructor(\n        query: IRemoveQuery, util: IDBUtil\n    ) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Remove, query);\n        if (err) return promiseReject(\n            err\n        );\n        let pResult: Promise<void>;\n        return beforeExecute().then(_ => {\n            try {\n                this.initTransaction_();\n                if (query.where != null) {\n                    if (isArray(query.where)) {\n                        pResult = this.processWhereArrayQry();\n                    }\n                    else {\n                        pResult = this.processWhere_();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n            return pResult.then(() => {\n                return this.rowAffected;\n            })\n        })\n    }\n\n    private processWhereArrayQry() {\n        const selectObject = new Select(this.query, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results) => {\n            const keyList = [];\n            const pkey = this.primaryKey(this.query.from);\n            results.forEach((item) => {\n                keyList.push(item[pkey]);\n            });\n            results = null;\n            const whereQry = { [pkey]: { [QUERY_OPTION.In]: keyList } };\n            this.query[QUERY_OPTION.Where] = whereQry;\n            return this.processWhere_();\n        })\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (value) => {\n            return this.whereChecker.check(value);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        });\n    }\n\n    private initTransaction_() {\n        if (!this.isTxQuery) {\n            this.util.createTransaction([this.query.from]);\n        }\n        this.objectStore = this.util.objectStore(this.query.from);\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private orQuerySuccess_() {\n        const orQueryFromOrInfo = (this as any)._orInfo.OrQuery\n        const key = getObjectFirstKey(orQueryFromOrInfo);\n        if (key != null) {\n            const where = {};\n            where[key] = orQueryFromOrInfo[key];\n            delete orQueryFromOrInfo[key];\n            this.query.where = where;\n            return this.goToWhereLogic().then(() => {\n                return this.onWhereEvaluated();\n            })\n        }\n        else {\n            this.isOr = true;\n        }\n    }\n\n    private processOrLogic() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        (this as any)._orInfo = {\n            OrQuery: where.or\n        };\n\n        // free or memory\n        delete where.or;\n    }\n}\n\nRemove.prototype.executeInLogic = executeInLogic;\nRemove.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nRemove.prototype.executeWhereLogic = executeWhereLogic;\nRemove.prototype.executeRegexLogic = executeRegexLogic;","import { Remove } from \".\";\nimport { promise, promiseAll } from \"@/common\";\nimport { onWhereRemove } from \"./where\";\n\nexport const executeInLogic = function (this: Remove, column, values) {\n    const columnIndex = this.objectStore.index(column)\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnIndex.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = onWhereRemove.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const executeWhereUndefinedLogic = function (this: Remove) {\n    let cursor;\n    const cursorRequest = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                cursor.delete();\n                ++this.rowAffected;\n                (cursor as any).continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { Remove } from \"./\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Remove, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    cursor.delete();\n                    ++this.rowAffected;\n                }\n                cursor.continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}","import { Base } from \"@executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\nimport { promise } from \"@/common\";\n\nexport class Clear extends Base {\n    constructor(tableName: string, util: IDBUtil) {\n        super();\n        this.query = tableName as any;\n        this.util = util;\n        this.tableName = tableName;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const tableName: string = this.query as any;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName, MetaHelper.tableName]);\n        }\n        return beforeExecute().then(_ => {\n            const clearRequest: IDBRequest = this.util.objectStore(tableName).clear();\n            try {\n                return promise<void>((res, rej) => {\n                    clearRequest.onsuccess = (e) => {\n                        const currentTable = this.table(tableName);\n                        for (const columnName in currentTable.autoIncColumnValue) {\n                            currentTable.autoIncColumnValue[columnName] = 0;\n                        }\n                        MetaHelper.set(MetaHelper.dbSchema, this.util.db, this.util).then(res).catch(rej);\n                    };\n\n                    clearRequest.onerror = rej;\n                })\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n        })\n    }\n}","import { Base } from \"@executors/base\";\nimport { ITranscationQuery, WebWorkerRequest, ERROR_TYPE, API, WebWorkerResult, promise } from \"@/common\";\nimport { IDBUtil } from \"@worker/idbutil\";\nimport { promiseReject, LogHelper, variableFromPath } from \"@worker/utils\";\nimport { Insert } from \"@executors/insert\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Remove } from \"@executors/remove\";\nimport { IQueryExecutor } from \"@/worker/interfaces\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Transaction extends Base {\n    results = {} as any;\n    reqQueue: WebWorkerRequest[] = [];\n    isQueryExecuting = false;\n\n    isTxStarted_ = false;\n\n    onSuccess: (result: any) => void;\n    onError: (err: LogHelper) => void;\n\n    beforeExecute: () => Promise<void>;\n\n    constructor(qry: ITranscationQuery, util: IDBUtil) {\n        super();\n        this.query = qry as any;\n        this.util = util;\n    }\n\n    execute(cb: () => Promise<void>) {\n        this.beforeExecute = cb;\n        const err = this.validate();\n        if (err) return promiseReject(\n            err\n        );\n        this.startExecution_()\n\n        return promise<void>((res, rej) => {\n            this.onSuccess = res;\n            this.onError = rej;\n        }).then(result => {\n            this.beforeExecute = null;\n            this.log(`transaction finished`);\n            return result;\n        })\n    }\n\n    validate() {\n        const query: ITranscationQuery = this.query as any;\n        const notExistingTable = this.notExistingTable_(query.tables);\n        if (notExistingTable) {\n            return new LogHelper(ERROR_TYPE.TableNotExist, { tableName: notExistingTable });\n        }\n        const methodName = query.method;\n        let txLogic = variableFromPath(methodName);\n        if (!txLogic) {\n            return new LogHelper(ERROR_TYPE.MethodNotExist, methodName);\n        }\n    }\n\n    private startExecution_() {\n        const query: ITranscationQuery = this.query as any;\n        const createPusher = (api: any) => {\n            return (qry) => {\n                return this.pushReq_({\n                    name: api,\n                    query: qry\n                } as WebWorkerRequest);\n            }\n        };\n        const setResult = (key: string, value) => {\n            this.results[key] = value;\n        };\n        const getResult = (key: string) => {\n            return this.results[key];\n        };\n        const abort = (msg: string) => {\n            this.abortTx_(msg);\n        };\n\n        const start = () => {\n            this.startTx_();\n        };\n        const methodName = query.method\n        let txLogic = variableFromPath(methodName);\n\n        this.log(`transaction query started`);\n\n        return txLogic.call(\n            this,\n            {\n                data: query.data,\n                insert: createPusher(API.Insert),\n                select: createPusher(API.Select),\n                update: createPusher(API.Update),\n                remove: createPusher(API.Remove),\n                count: createPusher(API.Count),\n                setResult: setResult,\n                getResult: getResult, abort: abort,\n                start: start\n            }\n        );\n    }\n\n    log(message) {\n        this.util.logger.log(message);\n    }\n\n    private startTx_() {\n        try {\n            this.isTxStarted_ = true;\n            let tableNames = (this.query as any).tables as string[];\n            tableNames = tableNames.concat(MetaHelper.tableName)\n            this.util.createTransaction(tableNames).then(_ => {\n                this.onSuccess(this.results);\n            }).catch(err => {\n                this.onError(err);\n            })\n            return this.processExecutionOfQry_();\n        }\n        catch (ex) {\n            this.onError(this.onException(ex) as any);\n        }\n    }\n\n\n\n\n\n    private onReqFinished_(result) {\n        const finisehdRequest = this.reqQueue.shift();\n\n        this.log(`finished request : ${finisehdRequest.name} `);\n\n        if (finisehdRequest) {\n            if (result.error) {\n                this.abortTx_(\"automatic abort of transaction due to error occured\");\n                this.log(`transaction aborted due to error occured`);\n                this.onError(result.error);\n            }\n            else {\n                this.isQueryExecuting = false;\n                if (finisehdRequest.onSuccess) {\n                    finisehdRequest.onSuccess(result);\n                }\n                this.processExecutionOfQry_();\n            }\n        }\n    }\n\n    private abortTx_(msg: string) {\n        this.reqQueue = [];\n        this.util.abortTransaction();\n        this.log(`transaction aborted. Msg : ${msg}`);\n\n    }\n\n    private executeRequest_(request: WebWorkerRequest) {\n        this.isQueryExecuting = true;\n        let requestObj: IQueryExecutor;\n        this.log(`executing request : ${request.name} `);\n        const onReqFinished = this.onReqFinished_.bind(this);\n        const query = request.query;\n\n        const callAPI = (api: typeof Select) => {\n            requestObj = new api(\n                query, this.util\n            );\n        };\n\n        switch (request.name) {\n            case API.Select:\n                callAPI(Select);\n                break;\n            case API.Insert:\n                callAPI(Insert as any);\n                break;\n            case API.Update:\n                callAPI(Update as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any);\n                break;\n            case API.Count:\n                callAPI(Count as any);\n                break;\n        }\n        requestObj.isTxQuery = true;\n        requestObj.execute(this.beforeExecute).then(onReqFinished).catch(err => {\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            onReqFinished(result);\n        })\n    }\n\n    private pushReq_(request: WebWorkerRequest) {\n        const promiseObj = promise((resolve, reject) => {\n            request.onSuccess = (result) => {\n                resolve(result);\n            };\n            request.onError = (error) => {\n                reject(error);\n            };\n        });\n        this.reqQueue.push(request);\n        if (this.isTxStarted_ === true) {\n            this.processExecutionOfQry_();\n        }\n\n        this.log(`request pushed : ${request.name}`);\n        return promiseObj;\n    }\n\n    private processExecutionOfQry_() {\n        if (this.isQueryExecuting === false) {\n            if (this.reqQueue.length > 0) {\n                this.executeRequest_(this.reqQueue[0]);\n            }\n        }\n    }\n\n    private notExistingTable_(tables: string[]) {\n        let invalidTable: string = null;\n        tables.every(tableName => {\n            const table = this.table(tableName);\n            if (table == null) {\n                invalidTable = tableName;\n                return false;\n            }\n            return true;\n        });\n        return invalidTable;\n    }\n}","import { DbMeta } from \"@worker/model\";\nimport { IDataBase, ITable } from \"@/common\";\n\nexport const userDbSchema = (db: DbMeta) => {\n    const database = {\n        name: db.name,\n        version: db.version,\n        tables: []\n    } as IDataBase;\n    db.tables.forEach(table => {\n        const tableAsObj = {\n            name: table.name,\n            columns: {}\n        } as ITable;\n        table.columns.forEach(column => {\n            tableAsObj.columns[column.name] = column;\n        });\n        database.tables.push(tableAsObj);\n    })\n    return database;\n}","import { WebWorkerRequest, promiseResolve, API, IDataBase, WebWorkerResult, promise, ERROR_TYPE, IDbInfo } from \"@/common\";\nimport { DbMeta } from \"./model\";\nimport { IDBUtil } from \"./idbutil\";\nimport { Insert } from \"@executors/insert\";\nimport { IS_WORKER, IS_IDB_SUPPORTED } from \"./constants\";\nimport { MetaHelper } from \"./meta_helper\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Intersect } from \"./intersect\";\nimport { DropDb } from \"@executors/drop_db\";\nimport { Union } from \"./union\";\nimport { Remove } from \"@executors/remove\";\nimport { Clear } from \"@executors/clear\";\nimport { Transaction } from \"@executors/transaction\";\nimport { LogHelper, getError, promiseReject, variableFromPath, userDbSchema, getLength } from \"@worker/utils\";\n\nexport class QueryManager {\n    util: IDBUtil;\n\n    get db() {\n        return this.util.db;\n    }\n\n    middlewares: string[] = [];\n\n    private onQryFinished;\n\n    protected get logger() {\n        return this.util.logger;\n    }\n\n    constructor(fn?: (result: any) => void) {\n        this.util = new IDBUtil();\n        this.onQryFinished = IS_WORKER ? (result) => {\n            self.postMessage(result);\n        } : fn;\n    }\n\n    private executeMiddleware_(request: WebWorkerRequest) {\n        const lastIndex = (getLength(this.middlewares) as any) - 1;\n        if (lastIndex < 0) {\n            return promiseResolve();\n        }\n        const middlewareContext = {};\n        const db = this.db;\n        Object.defineProperty(middlewareContext, 'database', {\n            get() {\n                return userDbSchema(db);\n            }\n        });\n        return promise<void>((res) => {\n            let index = 0;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = variableFromPath(this.middlewares[index++])(request, middlewareContext);\n                    if (!promiseResult || !promiseResult.then) {\n                        promiseResult = Promise.resolve(promiseResult);\n                    }\n                    promiseResult.then(_ => {\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res();\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    executeQuery(request: WebWorkerRequest, cb: () => Promise<any>) {\n        let queryResult: Promise<any>;\n        const query = request.query;\n        const ctx = this;\n        const idbutil = ctx.util;\n        const callAPI = (api: typeof Select, beforeExecute?: () => Promise<any>) => {\n            queryResult = new api(query, idbutil).\n                execute(beforeExecute);\n        };\n        switch (request.name) {\n            case API.OpenDb:\n                cb();\n                queryResult = ctx.openDb(query);\n                break;\n            case API.InitDb:\n                cb();\n                queryResult = ctx.initDb(query);\n                break;\n            case API.CloseDb:\n                cb();\n                queryResult = ctx.closeDb();\n                break;\n            case API.Insert:\n                callAPI(Insert as any, cb);\n                break;\n            case API.Select:\n                callAPI(Select as any, cb);\n                break;\n            case API.Count:\n                callAPI(Count as any, cb);\n                break;\n            case API.Update:\n                callAPI(Update as any, cb);\n                break;\n            case API.Intersect:\n                cb();\n                callAPI(Intersect as any);\n                break;\n            case API.DropDb:\n                cb();\n                queryResult = ctx.dropDb();\n                break;\n            case API.Terminate:\n                cb();\n                queryResult = ctx.terminate();\n                break;\n            case API.Union:\n                cb();\n                callAPI(Union as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any, cb);\n                break;\n            case API.Clear:\n                callAPI(Clear as any, cb);\n                break;\n            case API.Transaction:\n                callAPI(Transaction as any, cb);\n                break;\n            case API.Get:\n                cb();\n                queryResult = MetaHelper.get(query as string, idbutil);\n                break;\n            case API.Set:\n                cb();\n                queryResult = MetaHelper.set(query.key, query.value, idbutil);\n                break;\n            case API.ImportScripts:\n                cb();\n                queryResult = ctx.importScripts_(request);\n                break;\n            case API.ChangeLogStatus:\n                cb();\n                ctx.logger.status = query;\n                queryResult = Promise.resolve();\n                break;\n            case API.Middleware:\n                cb();\n                const value = variableFromPath(query);\n                if (!value) {\n                    return promiseReject(\n                        new LogHelper(ERROR_TYPE.InvalidMiddleware, query)\n                    );\n                }\n                ctx.middlewares.push(query);\n                return promiseResolve();\n            default:\n                if (process.env.NODE_ENV !== 'production') {\n                    console.error('The Api:-' + request.name + ' does not support.');\n                }\n                queryResult = promiseResolve();\n        }\n        ctx.logger.log(`Executing query ${request.name} in web worker`);\n        return queryResult;\n    }\n\n    private callMiddleware_(middlewares: any[], result?) {\n        return promise<any>((res) => {\n            let index = 0;\n            const lastIndex = (getLength(middlewares) as any) - 1;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = middlewares[index++](result);\n                    if (!(promiseResult instanceof Promise)) {\n                        promiseResult = promiseResolve(promiseResult);\n                    }\n                    promiseResult.then(modifiedResult => {\n                        result = modifiedResult;\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res(result);\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    run(request: WebWorkerRequest) {\n        let onResultCallback = [];\n        const beforeExecuteCallback = [];\n        request.onResult = (cb) => {\n            onResultCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        request.beforeExecute = (cb) => {\n            beforeExecuteCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        this.executeMiddleware_(request).then(_ => {\n            return this.executeQuery(request, () => {\n                return this.callMiddleware_(beforeExecuteCallback);\n            }).then((result) => {\n                return this.callMiddleware_(onResultCallback, result).then(modifiedResult => {\n                    this.returnResult_({\n                        result: modifiedResult\n                    });\n                });\n            });\n        }).catch(ex => {\n            onResultCallback = [];\n            const err = getError(ex);\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            this.returnResult_(result);\n        });\n    }\n\n    private importScripts_(request: WebWorkerRequest) {\n        return promise<void>((res, rej) => {\n            try {\n                importScripts(...request.query);\n                res();\n            } catch (e) {\n                const err = new LogHelper(ERROR_TYPE.ImportScriptsFailed, e.message);\n                rej(err);\n            }\n        });\n    }\n\n    private returnResult_(result: WebWorkerResult) {\n        this.logger.log(`Query finished inside web worker`);\n        if (this.util) {\n            this.util.emptyTx();\n        }\n        this.onQryFinished(result);\n    }\n\n    private dropDb() {\n        const dbName = this.db.name;\n        return this.terminate().then(() => {\n            return new DropDb().execute(dbName);\n        });\n    }\n\n    closeDb() {\n        return this.util.close();\n    }\n\n    terminate() {\n        return this.closeDb().then(() => {\n            this.util.db = null;\n        });\n    }\n\n    openDb(query: IDbInfo) {\n        return this.closeDb().then(_ => {\n            let pResult: Promise<boolean>;\n            if (this.db && query.name === this.db.name) {\n                pResult = this.initDb();\n            }\n            else {\n                pResult = this.initDb({\n                    name: query.name,\n                    tables: [\n                    ],\n                    version: query.version\n                });\n            }\n            return pResult.then(() => {\n                return this.db;\n            });\n        });\n    }\n\n    initDb(dataBase?: IDataBase) {\n        if (!IS_IDB_SUPPORTED) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.IndexedDbNotSupported)\n            );\n        }\n\n        const dbMeta = dataBase ? new DbMeta(dataBase) : this.db;\n        this.util = new IDBUtil();\n\n        return promise<boolean>((res, rej) => {\n            this.util.initDb(dbMeta).then((dbInfo) => {\n                if (dbInfo.isCreated) {\n                    MetaHelper.get(\n                        MetaHelper.dbSchema,\n                        this.util\n                    ).then((dbFromCache: DbMeta) => {\n                        if (dbFromCache) {\n                            dbFromCache.tables.forEach((tableFromCache, index) => {\n                                const targetTable = dbMeta.tables.find(q => q.name === tableFromCache.name);\n                                if (targetTable) {\n                                    for (const key in tableFromCache.autoIncColumnValue) {\n                                        const savedAutoIncrementValue = tableFromCache.autoIncColumnValue[key];\n                                        if (savedAutoIncrementValue) {\n                                            targetTable.autoIncColumnValue[key] = savedAutoIncrementValue;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                        this.util.db = dbMeta;\n                        dbInfo.database = userDbSchema(this.db);\n                        MetaHelper.set(\n                            MetaHelper.dbSchema, dbMeta,\n                            this.util\n                        ).then(() => {\n                            res(dbInfo);\n                        });\n                    });\n                }\n                else {\n                    MetaHelper.get(\n                        MetaHelper.dbSchema,\n                        this.util\n                    ).then((value: any) => {\n                        this.util.db = value;\n                        dbInfo.database = userDbSchema(this.db);\n                        res(dbInfo);\n                    });\n                }\n            }).catch(rej);\n        });\n    }\n}\n","import { QueryManager } from \"@/worker/query_manager\";\nimport { IS_WORKER } from \"./constants\";\nexport * from \"./query_manager\";\n\nif (IS_WORKER) {\n    const manager = new QueryManager();\n    (self as any).onmessage = function (e) {\n        manager.run(e.data);\n    };\n}\n\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","WORKER_STATUS","DATA_TYPE","API","EVENT","QUERY_OPTION","IDB_MODE","OCCURENCE","CONNECTION_STATUS","promiseResolve","Promise","resolve","promise","cb","ERROR_TYPE","table","columns","autoIncColumnValue","this","setColumn","name","alter","tableColumns","columnName","column","autoIncrement","primaryKey","enableSearch","existingColumnIndex","indexOf","q","push","existingColumn","assign","autoIncrementKey","tableName","set","util","tx","createTransaction","MetaHelper","store","objectStore","res","rej","req","put","onsuccess","onerror","keyRange","result","remove","delete","dbSchema","db","version","tables","map","TableMeta","forObj","type","info","info_","message","getMsg_","log","msg","status","console","throw","logError","error","errMsg","errorHandler","getInfo","errorType","method","logger","LogHelper","emptyTx","oncomplete","onabort","createTransactionIfNotExist","mode","ReadWrite","con","transaction","op","Between","IDBKeyRange","bound","low","high","GreaterThan","lowerBound","GreaterThanEqualTo","LessThan","upperBound","LessThanEqualTo","only","abortTransaction","abort","close","setTimeout","initDb","oldVersion","isDbCreated","dbVersion","dbOpenRequest","indexedDB","open","onversionchange","e","target","isCreated","newVersion","onupgradeneeded","upgradeConnection","storeNames","objectStoreNames","addColumn","indexNames","contains","options","unique","multiEntry","keyPath","createIndex","deleteColumn","index","findIndex","splice","deleteIndex","forEach","option","createObjectStore","i","alterQuery","add","drop","modify","shouldDelete","targetColumn","find","newColumn","storeName","item","qry","deleteObjectStore","length","promiseAll","promises","all","promiseReject","reject","getError","rowAffected","isTxQuery","results","query","from","meta","getColumnInfo","onException","ex","getErrorFromException","getDataType","Null","Array","isArray","Date","DateTime","isNull","isNaN","autoIncValues","autoIncrementValue","checkAndModifyValues","err","values","ignoreIndexes","every","checkAndModifyValue","ignore","checkAndModifyColumnValue_","checkNotNullAndDataType_","notNull","ColumnName","dataType","columnValue","Number","undefined","default","validation","details","check","setValue","tblName","checkByColumn_","checkFurther","allowedOp","validate","api","Select","Remove","Count","checkSelect","Insert","checkInsertQuery","Update","checkUpdate","getTable_","isInsertQryValid","into","SchemaChecker","in","where","checkForNullInWhere_","addGreatAndLessToNotOp_","whereQuery","containsNot","keys","NotEqualTo","addToSingleQry","Or","queryKeys","qryKeys","validResult","skipDataCheck","ValuesChecker","valuesAffected_","execute","beforeInsert","QueryHelper","then","_","insertData_","return","catch","onInsertData","addMethod","idbMethod","upsert","addResult","Base","IS_WORKER","self","alert","ServiceWorkerGlobalScope","IS_IDB_SUPPORTED","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","webkitIDBKeyRange","msIDBKeyRange","setCrossBrowserIndexedDb","getKeys","getLength","getObjectFirstKey","setCaseAndValue","caseQuery","caseQuery_","setCaseAndColumn","columnName_","caseColumnQuery_","length_","evaluate","checkCase_","lastThen","cond","queryOption","Equal","getCursorOnSuccess","simpleFn","limitFn","skipFn","skipAndLimitFn","limitAtEnd","skipAtEnd","skipRecord","limitRecord","executeSkipAndLimitForWhere_","onFinish","recordSkipped","cursor","shouldAddValue","pushResult","continue","advance","executeSkipForWhere_","executeLimitForWhere_","executeSimpleForWhere_","executeSkipAndLimit","onFinished","executeSkip","executeSimple","executeLimit","removeSpace","replace","getOrderColumnInfo","orderColumn","join","splittedByDot","split","joinOrderColumn","valueFromFirstColumn","isOrder","compareStringInDesc_","a","b","localeCompare","compareStringinAsc_","compareDefaultInDesc_","String","compareDefaultinAsc_","compareNumberInDesc_","compareNumberinAsc_","compareDateInDesc_","getTime","compareDateInAsc_","getValueComparer_","order","orderBy_","getOrderType_","by","thenEvaluator","getValInAscDesc","stringComparer","numberComparer","value1","value2","column1","column2","sortMethod","sort","columnInfo","case","toLowerCase","getRegexFromLikeExpression","likeExpression","filterValue","occurence","filterValues","Any","Last","First","RegExp","clone","copy","compare","compareValue","symbol","type1","checkFlag","props","last","pop","reduce","prev","curr","rowValue","whereColumnValue","In","checkIn","Like","checkLike_","Regex","checkRegex","checkComparisionOp_","test","goToWhereLogic","firstColumn","whereChecker","WhereChecker","executeWhereLogic","regexVal","executeRegexLogic","executeInLogic","Aggregate","skipOrPush","select","joinQueryStack_","currentQueryStackIndex_","tablesFetched","getTable","executeSelect","tablesToFetch","joinQueryStack","jointblInfo","getJoinTableInfo_","on","with","table1","table2","checkJoinQuery_","joinTableInfo","flatten","startExecutingJoinLogic_","onJoinQueryFinished_","selectApi","data","setLimitAndSkipEvaluationAtEnd_","processOrderBy","joinQuery","jointables","secondtableData","joinType","output","table1Index","table2Index","asQuery","as","mapWithAlias","asValue","val","valueMatchedFromSecondTable","callBack","columnDefaultValue","col","valueFromSecondTable","valueFromFirstTable","whereQry","whereCheker","performleftJoin","joinOn","splittedjoinOn","splittedjoinOnbydotFirst","splittedjoinOnbydotSecond","tableSchemaOf1stTable","tableSchemaOf2ndTable","columnFound","whereJoin","openCursor","cursorRequest","callOnSuccess","includes","sorted","isSubQuery","ThenEvaluator","returnResult_","Map","concat","processGroupDistinctAggr","skip","slice","limit","setPushResult","isArrayQry","orderQuery","groupBy","beforeExecute","initTransaction_","processWhereArrayQry","processWhere_","executeWhereUndefinedLogic","executeJoinQuery","bind","operation","pKey","isFirstWhere","onSuccess","andResults","And","keyValue","removeDuplicates","processFirstQry","whereQueryToProcess","shift","MemoryObjectStore","ReadOnly","or","processOrLogic_","onWhereEvaluated","isOr","orQuerySuccess_","orQueryFinish_","orInfo","orQuery","BaseFetch","idbSorting","orderType","dir","exp","datas","lookupObject","len","Join","distinct","aggregate","executeAggregateGroupBy","processGroupBy","processAggregateQry","orderQueryType","prevOrderQueryBy","currentOrderQuery","currentorderQueryBy","orderColumnDetail","columnToAggregate","datasLength","getCount","getMax","getMin","Infinity","getSum","getAvg","aggregateQry","aggregateColumn","aggregateValType","aggregateCalculator","objKey","grpQry","lookUpObj","calculateAggregate","getList","sumOfColumn","Max","Min","Sum","Avg","List","avgQuery","avg","sumForAvg","countForAvg","count","sum","isCountTypeString","isSumTypeString","avgColumn","groupByDataType","groupByColumn","onWhereCount","resultCount","queryHelper","getDataFromSelect","selectInstance","countRequest","isWhereKeysLengthOne","columnStore","variableFromPath","path","updateValue","storedValue","mapSet","columnSetValue","initTransaction","executeComplexLogic_","selectObject","ignoreCase","inQuery","cursorUpdateRequest","update","cursorOpenRequest","intersectQry","getHashKey","hashMap","hashMapTemp","isQueryForSameTable","queries","queryLength","columnValKey","fetchData","selectResult","resultPusher","dbName","dropDbRequest","deleteDatabase","onblocked","onWhereRemove","pResult","keyList","pkey","Where","processOrLogic","orQueryFromOrInfo","_orInfo","OrQuery","columnIndex","clearRequest","clear","currentTable","reqQueue","isQueryExecuting","isTxStarted_","startExecution_","onError","notExistingTable","notExistingTable_","methodName","createPusher","pushReq_","txLogic","insert","setResult","getResult","abortTx_","start","startTx_","tableNames","processExecutionOfQry_","onReqFinished_","finisehdRequest","executeRequest_","request","requestObj","onReqFinished","callAPI","promiseObj","invalidTable","userDbSchema","database","tableAsObj","fn","middlewares","IDBUtil","onQryFinished","postMessage","executeMiddleware_","lastIndex","middlewareContext","callNextMiddleware","promiseResult","executeQuery","queryResult","ctx","idbutil","OpenDb","openDb","InitDb","CloseDb","closeDb","Intersect","DropDb","dropDb","Terminate","terminate","Union","Clear","Transaction","Get","Set","ImportScripts","importScripts_","ChangeLogStatus","Middleware","callMiddleware_","modifiedResult","run","onResultCallback","beforeExecuteCallback","onResult","importScripts","dataBase","dbMeta","DbMeta","dbInfo","dbFromCache","tableFromCache","targetTable","savedAutoIncrementValue","QueryManager","onmessage"],"sourceRoot":""}